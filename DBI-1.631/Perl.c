/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2210 from the
 * contents of Perl.xs. Do not edit this file, edit Perl.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "Perl.xs"
/* This is a skeleton driver that only serves as a basic sanity check
   that the Driver.xst mechansim doesn't have compile-time errors in it.
   vim: ts=8:sw=4:expandtab
*/

#define PERL_NO_GET_CONTEXT
#include "DBIXS.h"
#include "dbd_xsh.h"

#undef DBIh_SET_ERR_CHAR        /* to syntax check emulation */
#include "dbivport.h"

DBISTATE_DECLARE;


struct imp_drh_st {
    dbih_drc_t com;     /* MUST be first element in structure   */
};
struct imp_dbh_st {
    dbih_dbc_t com;     /* MUST be first element in structure   */
};
struct imp_sth_st {
    dbih_stc_t com;     /* MUST be first element in structure   */
};



#define dbd_discon_all(drh, imp_drh)            (drh=drh,imp_drh=imp_drh,1)
#define dbd_dr_data_sources(drh, imp_drh, attr) (drh=drh,imp_drh=imp_drh,Nullav)
#define dbd_db_do4(dbh,imp_dbh,p3,p4)           (dbh=dbh,imp_dbh=imp_dbh,p3=p3,p4=p4,-2)
#define dbd_db_last_insert_id(dbh, imp_dbh, p3,p4,p5,p6, attr) \
        (dbh=dbh,imp_dbh=imp_dbh,p3=p3,p4=p4,p5=p5,p6=p6,&PL_sv_undef)
#define dbd_take_imp_data(h, imp_xxh, p3)       (h=h,imp_xxh=imp_xxh,&PL_sv_undef)
#define dbd_st_execute_for_fetch(sth, imp_sth, p3, p4) \
        (sth=sth,imp_sth=imp_sth,p3=p3,p4=p4,&PL_sv_undef)

#define dbd_st_bind_col(sth, imp_sth, param, ref, sql_type, attribs) \
        (sth=sth,imp_sth=imp_sth,param=param,ref=ref,sql_type=sql_type,attribs=attribs,1)

int     /* just to test syntax of macros etc */
dbd_st_rows(SV *h, imp_sth_t *imp_sth)
{
    dTHX;
    PERL_UNUSED_VAR(h);
    DBIh_SET_ERR_CHAR(h, imp_sth, 0, 1, "err msg", "12345", Nullch);
    return -1;
}


#line 60 "Perl.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 112 "Perl.c"

/* INCLUDE:  Including 'Perl.xsi' from 'Perl.xs' */

#include "Driver_xst.h"

XS(XS_DBD__Perl__dr_dbixs_revision); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__dr_dbixs_revision)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 36 "./Perl.xsi"
    ST(0) = sv_2mortal(newSViv(DBIXS_REVISION));
#line 132 "Perl.c"
	PUTBACK;
	return;
    }
}

#ifdef dbd_discon_all
#define XSubPPtmpAAAA 1


XS(XS_DBD__Perl__dr_discon_all_); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__dr_discon_all_)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "drh");
    {
	SV *	drh = ST(0);
#line 48 "./Perl.xsi"
    D_imp_drh(drh);
    PERL_UNUSED_VAR(ix);
    ST(0) = dbd_discon_all(drh, imp_drh) ? &PL_sv_yes : &PL_sv_no;
#line 159 "Perl.c"
    }
    XSRETURN(1);
}

#endif /* dbd_discon_all */
#ifdef dbd_dr_data_sources
#define XSubPPtmpAAAB 1


XS(XS_DBD__Perl__dr_data_sources); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__dr_data_sources)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "drh, attr = Nullsv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	drh = ST(0);
	SV *	attr;

	if (items < 2)
	    attr = Nullsv;
	else {
	    attr = ST(1);
	}
#line 62 "./Perl.xsi"
    {
        D_imp_drh(drh);
        AV *av = dbd_dr_data_sources(drh, imp_drh, attr);
        if (av) {
            int i;
            int n = AvFILL(av)+1;
            EXTEND(sp, n);
            for (i = 0; i < n; ++i) {
                PUSHs(AvARRAY(av)[i]);
            }
        }
    }
#line 203 "Perl.c"
	PUTBACK;
	return;
    }
}

#endif

XS(XS_DBD__Perl__db__login); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__db__login)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 4 || items > 5)
       croak_xs_usage(cv,  "dbh, dbname, username, password, attribs=Nullsv");
    {
	SV *	dbh = ST(0);
	SV *	dbname = ST(1);
	SV *	username = ST(2);
	SV *	password = ST(3);
	SV *	attribs;

	if (items < 5)
	    attribs = Nullsv;
	else {
	    attribs = ST(4);
	}
#line 92 "./Perl.xsi"
    {
    D_imp_dbh(dbh);
#if !defined(dbd_db_login6_sv)
    STRLEN lna;
    char *u = (SvOK(username)) ? SvPV(username,lna) : (char*)"";
    char *p = (SvOK(password)) ? SvPV(password,lna) : (char*)"";
#endif
#ifdef dbd_db_login6_sv
    ST(0) = dbd_db_login6_sv(dbh, imp_dbh, dbname, username, password, attribs) ? &PL_sv_yes : &PL_sv_no;
#elif defined(dbd_db_login6)
    ST(0) = dbd_db_login6(dbh, imp_dbh, SvPV_nolen(dbname), u, p, attribs) ? &PL_sv_yes : &PL_sv_no;
#else
    ST(0) = dbd_db_login( dbh, imp_dbh, SvPV_nolen(dbname), u, p) ? &PL_sv_yes : &PL_sv_no;
#endif
    }
#line 249 "Perl.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Perl__db_selectall_arrayref); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__db_selectall_arrayref)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 112 "./Perl.xsi"
    SV *sth;
    SV **maxrows_svp;
    SV **tmp_svp;
    SV *tmp_sv;
    SV *attr = &PL_sv_undef;
    imp_sth_t *imp_sth;
#line 272 "Perl.c"
#line 119 "./Perl.xsi"
    if (items > 2) {
        attr = ST(2);
        if (SvROK(attr) &&
                (DBD_ATTRIB_TRUE(attr,"Slice",5,tmp_svp) || DBD_ATTRIB_TRUE(attr,"Columns",7,tmp_svp))
        ) {
            /* fallback to perl implementation */
            SV *tmp =dbixst_bounce_method("DBD::Perl::db::SUPER::selectall_arrayref", items);
            SPAGAIN;
            ST(0) = tmp;
            XSRETURN(1);
        }
    }
    /* --- prepare --- */
    if (SvROK(ST(1))) {
        MAGIC *mg;
        sth = ST(1);
        /* switch to inner handle if not already */
        if ( (mg = mg_find(SvRV(sth),'P')) )
            sth = mg->mg_obj;
    }
    else {
        sth = dbixst_bounce_method("prepare", 3);
        SPAGAIN; SP -= items; /* because stack might have been realloc'd */
        if (!SvROK(sth))
            XSRETURN_UNDEF;
        /* switch to inner handle */
        sth = mg_find(SvRV(sth),'P')->mg_obj;
    }
    imp_sth = (imp_sth_t*)(DBIh_COM(sth));
    /* --- bind_param --- */
    if (items > 3) {    /* need to bind params before execute */
        if (!dbdxst_bind_params(sth, imp_sth, items-2, ax+2) ) {
            XSRETURN_UNDEF;
        }
    }
    /* --- execute --- */
    DBIc_ROW_COUNT(imp_sth) = 0;
    if ( dbd_st_execute(sth, imp_sth) <= -2 ) { /* -2 == error */
        XSRETURN_UNDEF;
    }
    /* --- fetchall --- */
    maxrows_svp = DBD_ATTRIB_GET_SVP(attr, "MaxRows", 7);
    tmp_sv = dbdxst_fetchall_arrayref(sth, &PL_sv_undef, (maxrows_svp) ? *maxrows_svp : &PL_sv_undef);
    SPAGAIN;
    ST(0) = tmp_sv;
#line 319 "Perl.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Perl__db_selectrow_arrayref); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__db_selectrow_arrayref)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 171 "./Perl.xsi"
    int is_selectrow_array = (ix == 1);
    imp_sth_t *imp_sth;
    SV *sth;
    AV *row_av;
#line 343 "Perl.c"
#line 176 "./Perl.xsi"
    if (SvROK(ST(1))) {
        MAGIC *mg;
        sth = ST(1);
        /* switch to inner handle if not already */
        if ( (mg = mg_find(SvRV(sth),'P')) )
            sth = mg->mg_obj;
    }
    else {
        /* --- prepare --- */
        sth = dbixst_bounce_method("prepare", 3);
        SPAGAIN; SP -= items; /* because stack might have been realloc'd */
        if (!SvROK(sth)) {
            if (is_selectrow_array) { XSRETURN_EMPTY; } else { XSRETURN_UNDEF; }
        }
        /* switch to inner handle */
        sth = mg_find(SvRV(sth),'P')->mg_obj;
    }
    imp_sth = (imp_sth_t*)(DBIh_COM(sth));
    /* --- bind_param --- */
    if (items > 3) {    /* need to bind params before execute */
        if (!dbdxst_bind_params(sth, imp_sth, items-2, ax+2) ) {
            if (is_selectrow_array) { XSRETURN_EMPTY; } else { XSRETURN_UNDEF; }
        }
    }
    /* --- execute --- */
    DBIc_ROW_COUNT(imp_sth) = 0;
    if ( dbd_st_execute(sth, imp_sth) <= -2 ) { /* -2 == error */
        if (is_selectrow_array) { XSRETURN_EMPTY; } else { XSRETURN_UNDEF; }
    }
    /* --- fetchrow_arrayref --- */
    row_av = dbd_st_fetch(sth, imp_sth);
    if (!row_av) {
        if (GIMME == G_SCALAR)
            PUSHs(&PL_sv_undef);
    }
    else if (is_selectrow_array) {
        int i;
        int num_fields = AvFILL(row_av)+1;
        if (GIMME == G_SCALAR)
            num_fields = 1; /* return just first field */
        EXTEND(sp, num_fields);
        for(i=0; i < num_fields; ++i) {
            PUSHs(AvARRAY(row_av)[i]);
        }
    }
    else {
        PUSHs( sv_2mortal(newRV((SV *)row_av)) );
    }
    /* --- finish --- */
#ifdef dbd_st_finish3
    dbd_st_finish3(sth, imp_sth, 0);
#else
    dbd_st_finish(sth, imp_sth);
#endif
#line 399 "Perl.c"
	PUTBACK;
	return;
    }
}

#ifdef dbd_db_do4 /* deebeedee-deebee-doo, deebee-doobee-dah? */
#define XSubPPtmpAAAC 1


XS(XS_DBD__Perl__db_do); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__db_do)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "dbh, statement, params = Nullsv");
    {
	SV *	dbh = ST(0);
	char *	statement = (char *)SvPV_nolen(ST(1));
	SV *	params;

	if (items < 3)
	    params = Nullsv;
	else {
	    params = ST(2);
	}
#line 240 "./Perl.xsi"
    {
    D_imp_dbh(dbh);
    IV retval;
    retval = dbd_db_do4(dbh, imp_dbh, statement, params);
    /* remember that dbd_db_do4 must return <= -2 for error     */
    if (retval == 0)            /* ok with no rows affected     */
        XST_mPV(0, "0E0");      /* (true but zero)              */
    else if (retval < -1)       /* -1 == unknown number of rows */
        XST_mUNDEF(0);          /* <= -2 means error            */
    else
        XST_mIV(0, retval);     /* typically 1, rowcount or -1  */
    }
#line 442 "Perl.c"
    }
    XSRETURN(1);
}

#endif
#ifdef dbd_db_last_insert_id
#define XSubPPtmpAAAD 1


XS(XS_DBD__Perl__db_last_insert_id); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__db_last_insert_id)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 5 || items > 6)
       croak_xs_usage(cv,  "dbh, catalog, schema, table, field, attr=Nullsv");
    {
	SV *	dbh = ST(0);
	SV *	catalog = ST(1);
	SV *	schema = ST(2);
	SV *	table = ST(3);
	SV *	field = ST(4);
	SV *	attr;

	if (items < 6)
	    attr = Nullsv;
	else {
	    attr = ST(5);
	}
#line 267 "./Perl.xsi"
    {
    D_imp_dbh(dbh);
    ST(0) = dbd_db_last_insert_id(dbh, imp_dbh, catalog, schema, table, field, attr);
    }
#line 480 "Perl.c"
    }
    XSRETURN(1);
}

#endif

XS(XS_DBD__Perl__db_commit); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__db_commit)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0);
#line 279 "./Perl.xsi"
    D_imp_dbh(dbh);
    if (DBIc_has(imp_dbh,DBIcf_AutoCommit) && DBIc_WARN(imp_dbh))
        warn("commit ineffective with AutoCommit enabled");
    ST(0) = dbd_db_commit(dbh, imp_dbh) ? &PL_sv_yes : &PL_sv_no;
#line 504 "Perl.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Perl__db_rollback); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__db_rollback)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0);
#line 289 "./Perl.xsi"
    D_imp_dbh(dbh);
    if (DBIc_has(imp_dbh,DBIcf_AutoCommit) && DBIc_WARN(imp_dbh))
        warn("rollback ineffective with AutoCommit enabled");
    ST(0) = dbd_db_rollback(dbh, imp_dbh) ? &PL_sv_yes : &PL_sv_no;
#line 527 "Perl.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Perl__db_disconnect); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__db_disconnect)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0);
#line 299 "./Perl.xsi"
    D_imp_dbh(dbh);
    if ( !DBIc_ACTIVE(imp_dbh) ) {
        XSRETURN_YES;
    }
    /* Check for disconnect() being called whilst refs to cursors       */
    /* still exists. This possibly needs some more thought.             */
    if (DBIc_ACTIVE_KIDS(imp_dbh) && DBIc_WARN(imp_dbh) && !PL_dirty) {
        STRLEN lna;
        char *plural = (DBIc_ACTIVE_KIDS(imp_dbh)==1) ? (char*)"" : (char*)"s";
        warn("%s->disconnect invalidates %d active statement handle%s %s",
            SvPV(dbh,lna), (int)DBIc_ACTIVE_KIDS(imp_dbh), plural,
            "(either destroy statement handles or call finish on them before disconnecting)");
    }
    ST(0) = dbd_db_disconnect(dbh, imp_dbh) ? &PL_sv_yes : &PL_sv_no;
    DBIc_ACTIVE_off(imp_dbh);   /* ensure it's off, regardless */
#line 561 "Perl.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Perl__db_STORE); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__db_STORE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "dbh, keysv, valuesv");
    {
	SV *	dbh = ST(0);
	SV *	keysv = ST(1);
	SV *	valuesv = ST(2);
#line 322 "./Perl.xsi"
    D_imp_dbh(dbh);
    if (SvGMAGICAL(valuesv))
        mg_get(valuesv);
    ST(0) = &PL_sv_yes;
    if (!dbd_db_STORE_attrib(dbh, imp_dbh, keysv, valuesv))
        if (!DBIc_DBISTATE(imp_dbh)->set_attr(dbh, keysv, valuesv))
            ST(0) = &PL_sv_no;
#line 589 "Perl.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Perl__db_FETCH); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__db_FETCH)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "dbh, keysv");
    {
	SV *	dbh = ST(0);
	SV *	keysv = ST(1);
#line 336 "./Perl.xsi"
    D_imp_dbh(dbh);
    SV *valuesv = dbd_db_FETCH_attrib(dbh, imp_dbh, keysv);
    if (!valuesv)
        valuesv = DBIc_DBISTATE(imp_dbh)->get_attr(dbh, keysv);
    ST(0) = valuesv;    /* dbd_db_FETCH_attrib did sv_2mortal   */
#line 614 "Perl.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Perl__db_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__db_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	dbh = ST(0);
#line 347 "./Perl.xsi"
    /* keep in sync with default DESTROY in DBI.xs */
    D_imp_dbh(dbh);
    ST(0) = &PL_sv_yes;
    if (!DBIc_IMPSET(imp_dbh)) {        /* was never fully set up       */
        STRLEN lna;
        if (DBIc_WARN(imp_dbh) && !PL_dirty && DBIc_DBISTATE(imp_dbh)->debug >= 2)
             PerlIO_printf(DBIc_LOGPIO(imp_dbh),
                "         DESTROY for %s ignored - handle not initialised\n",
                    SvPV(dbh,lna));
    }
    else {
        if (DBIc_IADESTROY(imp_dbh)) {            /* wants ineffective destroy */
            DBIc_ACTIVE_off(imp_dbh);
            if (DBIc_DBISTATE(imp_dbh)->debug)
                 PerlIO_printf(DBIc_LOGPIO(imp_dbh), "         DESTROY %s skipped due to InactiveDestroy\n", SvPV_nolen(dbh));
        }
        if (DBIc_ACTIVE(imp_dbh)) {
            if (!DBIc_has(imp_dbh,DBIcf_AutoCommit)) {
                /* Application is using transactions and hasn't explicitly disconnected.
                    Some databases will automatically commit on graceful disconnect.
                    Since we're about to gracefully disconnect as part of the DESTROY
                    we want to be sure we're not about to implicitly commit changes
                    that are incomplete and should be rolled back. (The DESTROY may
                    be due to a RaiseError, for example.) So we rollback here.
                    This will be harmless if the application has issued a commit,
                    XXX Could add an attribute flag to indicate that the driver
                    doesn't have this problem. Patches welcome.
                */
                if (DBIc_WARN(imp_dbh) /* only warn if likely to be useful... */
                &&  DBIc_is(imp_dbh, DBIcf_Executed) /* has not just called commit/rollback */
            /*  && !DBIc_is(imp_dbh, DBIcf_ReadOnly) -- is not read only */
                && (!PL_dirty || DBIc_DBISTATE(imp_dbh)->debug >= 3)
                ) {
                    warn("Issuing rollback() due to DESTROY without explicit disconnect() of %s handle %s",
                        SvPV_nolen(*hv_fetch((HV*)SvRV(dbh), "ImplementorClass", 16, 1)),
                        SvPV_nolen(*hv_fetch((HV*)SvRV(dbh), "Name", 4, 1))
                    );
                }
                dbd_db_rollback(dbh, imp_dbh);                  /* ROLLBACK! */
            }
            dbd_db_disconnect(dbh, imp_dbh);
            DBIc_ACTIVE_off(imp_dbh);   /* ensure it's off, regardless */
        }
        dbd_db_destroy(dbh, imp_dbh);
    }
#line 680 "Perl.c"
	PUTBACK;
	return;
    }
}

#ifdef dbd_take_imp_data
#define XSubPPtmpAAAE 1


XS(XS_DBD__Perl__db_take_imp_data); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__db_take_imp_data)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "h");
    {
	SV *	h = ST(0);
#line 400 "./Perl.xsi"
    D_imp_xxh(h);
    /* dbd_take_imp_data() returns &sv_no (or other defined but false value)
     * to indicate "preparations complete, now call SUPER::take_imp_data" for me.
     * Anything else is returned to the caller via sv_2mortal(sv), typically that
     * would be &sv_undef for error or an SV holding the imp_data.
     */
    SV *sv = dbd_take_imp_data(h, imp_xxh, NULL);
    if (SvOK(sv) && !SvTRUE(sv)) {
        SV *tmp = dbixst_bounce_method("DBD::Perl::db::SUPER::take_imp_data", items);
        SPAGAIN;
        ST(0) = tmp;
    } else {
        ST(0) = sv_2mortal(sv);
    }
#line 717 "Perl.c"
    }
    XSRETURN(1);
}

#endif
#ifdef dbd_db_data_sources
#define XSubPPtmpAAAF 1


XS(XS_DBD__Perl__db_data_sources); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__db_data_sources)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "dbh, attr = Nullsv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	dbh = ST(0);
	SV *	attr;

	if (items < 2)
	    attr = Nullsv;
	else {
	    attr = ST(1);
	}
#line 424 "./Perl.xsi"
    {
        D_imp_dbh(dbh);
        AV *av = dbd_db_data_sources(dbh, imp_dbh, attr);
        if (av) {
            int i;
            int n = AvFILL(av)+1;
            EXTEND(sp, n);
            for (i = 0; i < n; ++i) {
                PUSHs(AvARRAY(av)[i]);
            }
        }
    }
#line 761 "Perl.c"
	PUTBACK;
	return;
    }
}

#endif

XS(XS_DBD__Perl__st__prepare); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__st__prepare)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "sth, statement, attribs=Nullsv");
    {
	SV *	sth = ST(0);
	SV *	statement = ST(1);
	SV *	attribs;

	if (items < 3)
	    attribs = Nullsv;
	else {
	    attribs = ST(2);
	}
#line 453 "./Perl.xsi"
    {
    D_imp_sth(sth);
    DBD_ATTRIBS_CHECK("_prepare", sth, attribs);
#ifdef dbd_st_prepare_sv
    ST(0) = dbd_st_prepare_sv(sth, imp_sth, statement, attribs) ? &PL_sv_yes : &PL_sv_no;
#else
    ST(0) = dbd_st_prepare(sth, imp_sth, SvPV_nolen(statement), attribs) ? &PL_sv_yes : &PL_sv_no;
#endif
    }
#line 799 "Perl.c"
    }
    XSRETURN(1);
}

#ifdef dbd_st_rows
#define XSubPPtmpAAAG 1


XS(XS_DBD__Perl__st_rows); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__st_rows)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0);
#line 470 "./Perl.xsi"
    D_imp_sth(sth);
    XST_mIV(0, dbd_st_rows(sth, imp_sth));
#line 823 "Perl.c"
    }
    XSRETURN(1);
}

#endif /* dbd_st_rows */
#ifdef dbd_st_bind_col
#define XSubPPtmpAAAH 1


XS(XS_DBD__Perl__st_bind_col); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__st_bind_col)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "sth, col, ref, attribs=Nullsv");
    {
	SV *	sth = ST(0);
	SV *	col = ST(1);
	SV *	ref = ST(2);
	SV *	attribs;

	if (items < 4)
	    attribs = Nullsv;
	else {
	    attribs = ST(3);
	}
#line 485 "./Perl.xsi"
    {
    IV sql_type = 0;
    D_imp_sth(sth);
    if (SvGMAGICAL(ref))
        mg_get(ref);
    if (attribs) {
        if (SvNIOK(attribs)) {
            sql_type = SvIV(attribs);
            attribs = Nullsv;
        }
        else {
            SV **svp;
            DBD_ATTRIBS_CHECK("bind_col", sth, attribs);
            /* XXX we should perhaps complain if TYPE is not SvNIOK */
            DBD_ATTRIB_GET_IV(attribs, "TYPE",4, svp, sql_type);
        }
    }
    switch(dbd_st_bind_col(sth, imp_sth, col, ref, sql_type, attribs)) {
    case 2:     ST(0) = &PL_sv_yes;        /* job done completely */
                break;
    case 1:     /* fallback to DBI default */
                ST(0) = (DBIc_DBISTATE(imp_sth)->bind_col(sth, col, ref, attribs))
                    ? &PL_sv_yes : &PL_sv_no;
                break;
    default:    ST(0) = &PL_sv_no;         /* dbd_st_bind_col has called set_err */
                break;
    }
    }
#line 883 "Perl.c"
    }
    XSRETURN(1);
}

#endif /* dbd_st_bind_col */

XS(XS_DBD__Perl__st_bind_param); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__st_bind_param)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "sth, param, value, attribs=Nullsv");
    {
	SV *	sth = ST(0);
	SV *	param = ST(1);
	SV *	value = ST(2);
	SV *	attribs;

	if (items < 4)
	    attribs = Nullsv;
	else {
	    attribs = ST(3);
	}
#line 523 "./Perl.xsi"
    {
    IV sql_type = 0;
    D_imp_sth(sth);
    if (SvGMAGICAL(value))
        mg_get(value);
    if (attribs) {
        if (SvNIOK(attribs)) {
            sql_type = SvIV(attribs);
            attribs = Nullsv;
        }
        else {
            SV **svp;
            DBD_ATTRIBS_CHECK("bind_param", sth, attribs);
            /* XXX we should perhaps complain if TYPE is not SvNIOK */
            DBD_ATTRIB_GET_IV(attribs, "TYPE",4, svp, sql_type);
        }
    }
    ST(0) = dbd_bind_ph(sth, imp_sth, param, value, sql_type, attribs, FALSE, 0)
                ? &PL_sv_yes : &PL_sv_no;
    }
#line 932 "Perl.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Perl__st_bind_param_inout); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__st_bind_param_inout)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 4 || items > 5)
       croak_xs_usage(cv,  "sth, param, value_ref, maxlen, attribs=Nullsv");
    {
	SV *	sth = ST(0);
	SV *	param = ST(1);
	SV *	value_ref = ST(2);
	IV	maxlen = (IV)SvIV(ST(3));
	SV *	attribs;

	if (items < 5)
	    attribs = Nullsv;
	else {
	    attribs = ST(4);
	}
#line 553 "./Perl.xsi"
    {
    IV sql_type = 0;
    D_imp_sth(sth);
    SV *value;
    if (!SvROK(value_ref) || SvTYPE(SvRV(value_ref)) > SVt_PVMG)
        croak("bind_param_inout needs a reference to a scalar value");
    value = SvRV(value_ref);
    if (SvREADONLY(value))
        croak("Modification of a read-only value attempted");
    if (SvGMAGICAL(value))
        mg_get(value);
    if (attribs) {
        if (SvNIOK(attribs)) {
            sql_type = SvIV(attribs);
            attribs = Nullsv;
        }
        else {
            SV **svp;
            DBD_ATTRIBS_CHECK("bind_param", sth, attribs);
            DBD_ATTRIB_GET_IV(attribs, "TYPE",4, svp, sql_type);
        }
    }
    ST(0) = dbd_bind_ph(sth, imp_sth, param, value, sql_type, attribs, TRUE, maxlen)
                ? &PL_sv_yes : &PL_sv_no;
    }
#line 986 "Perl.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Perl__st_execute); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__st_execute)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "sth, ...");
    {
	SV *	sth = ST(0);
#line 584 "./Perl.xsi"
    D_imp_sth(sth);
    int retval;
    if (items > 1) {    /* need to bind params */
        if (!dbdxst_bind_params(sth, imp_sth, items, ax) ) {
            XSRETURN_UNDEF;
        }
    }
    /* XXX this code is duplicated in selectrow_arrayref above  */
    if (DBIc_ROW_COUNT(imp_sth) > 0) /* reset for re-execute */
        DBIc_ROW_COUNT(imp_sth) = 0;
    retval = dbd_st_execute(sth, imp_sth);
    /* remember that dbd_st_execute must return <= -2 for error */
    if (retval == 0)            /* ok with no rows affected     */
        XST_mPV(0, "0E0");      /* (true but zero)              */
    else if (retval < -1)       /* -1 == unknown number of rows */
        XST_mUNDEF(0);          /* <= -2 means error            */
    else
        XST_mIV(0, retval);     /* typically 1, rowcount or -1  */
#line 1023 "Perl.c"
    }
    XSRETURN(1);
}

#ifdef dbd_st_execute_for_fetch
#define XSubPPtmpAAAI 1


XS(XS_DBD__Perl__st_execute_for_fetch); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__st_execute_for_fetch)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "sth, fetch_tuple_sub, tuple_status = Nullsv");
    {
	SV *	sth = ST(0);
	SV *	fetch_tuple_sub = ST(1);
	SV *	tuple_status;

	if (items < 3)
	    tuple_status = Nullsv;
	else {
	    tuple_status = ST(2);
	}
#line 612 "./Perl.xsi"
    {
    D_imp_sth(sth);
    ST(0) = dbd_st_execute_for_fetch(sth, imp_sth, fetch_tuple_sub, tuple_status);
    }
#line 1057 "Perl.c"
    }
    XSRETURN(1);
}

#endif

XS(XS_DBD__Perl__st_fetchrow_arrayref); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__st_fetchrow_arrayref)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0);
#line 627 "./Perl.xsi"
    D_imp_sth(sth);
    AV *av;
    PERL_UNUSED_VAR(ix);
    av = dbd_st_fetch(sth, imp_sth);
    ST(0) = (av) ? sv_2mortal(newRV((SV *)av)) : &PL_sv_undef;
#line 1083 "Perl.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Perl__st_fetchrow_array); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__st_fetchrow_array)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	sth = ST(0);
#line 640 "./Perl.xsi"
    D_imp_sth(sth);
    AV *av;
    av = dbd_st_fetch(sth, imp_sth);
    if (av) {
        int i;
        int num_fields = AvFILL(av)+1;
        EXTEND(sp, num_fields);
        for(i=0; i < num_fields; ++i) {
            PUSHs(AvARRAY(av)[i]);
        }
        PERL_UNUSED_VAR(ix);
    }
#line 1117 "Perl.c"
	PUTBACK;
	return;
    }
}


XS(XS_DBD__Perl__st_fetchall_arrayref); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__st_fetchall_arrayref)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "sth, slice=&PL_sv_undef, batch_row_count=&PL_sv_undef");
    {
	SV *	sth = ST(0);
	SV *	slice;
	SV *	batch_row_count;

	if (items < 2)
	    slice = &PL_sv_undef;
	else {
	    slice = ST(1);
	}

	if (items < 3)
	    batch_row_count = &PL_sv_undef;
	else {
	    batch_row_count = ST(2);
	}
#line 660 "./Perl.xsi"
    if (SvOK(slice)) {  /* fallback to perl implementation */
        SV *tmp = dbixst_bounce_method("DBD::Perl::st::SUPER::fetchall_arrayref", 3);
        SPAGAIN;
        ST(0) = tmp;
    }
    else {
        SV *tmp = dbdxst_fetchall_arrayref(sth, slice, batch_row_count);
        SPAGAIN;
        ST(0) = tmp;
    }
#line 1161 "Perl.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Perl__st_finish); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__st_finish)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0);
#line 676 "./Perl.xsi"
    D_imp_sth(sth);
    D_imp_dbh_from_sth;
    if (!DBIc_ACTIVE(imp_sth)) {
        /* No active statement to finish        */
        XSRETURN_YES;
    }
    if (!DBIc_ACTIVE(imp_dbh)) {
        /* Either an explicit disconnect() or global destruction        */
        /* has disconnected us from the database. Finish is meaningless */
        DBIc_ACTIVE_off(imp_sth);
        XSRETURN_YES;
    }
#ifdef dbd_st_finish3
    ST(0) = dbd_st_finish3(sth, imp_sth, 0) ? &PL_sv_yes : &PL_sv_no;
#else
    ST(0) = dbd_st_finish(sth, imp_sth) ? &PL_sv_yes : &PL_sv_no;
#endif
#line 1197 "Perl.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Perl__st_blob_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__st_blob_read)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 4 || items > 6)
       croak_xs_usage(cv,  "sth, field, offset, len, destrv=Nullsv, destoffset=0");
    {
	SV *	sth = ST(0);
	int	field = (int)SvIV(ST(1));
	long	offset = (long)SvIV(ST(2));
	long	len = (long)SvIV(ST(3));
	SV *	destrv;
	long	destoffset;

	if (items < 5)
	    destrv = Nullsv;
	else {
	    destrv = ST(4);
	}

	if (items < 6)
	    destoffset = 0;
	else {
	    destoffset = (long)SvIV(ST(5));
	}
#line 704 "./Perl.xsi"
    {
    D_imp_sth(sth);
    if (!destrv)
        destrv = sv_2mortal(newRV(sv_2mortal(newSV(0))));
    if (dbd_st_blob_read(sth, imp_sth, field, offset, len, destrv, destoffset))
         ST(0) = SvRV(destrv);
    else ST(0) = &PL_sv_undef;
    }
#line 1241 "Perl.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Perl__st_STORE); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__st_STORE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "sth, keysv, valuesv");
    {
	SV *	sth = ST(0);
	SV *	keysv = ST(1);
	SV *	valuesv = ST(2);
#line 720 "./Perl.xsi"
    D_imp_sth(sth);
    if (SvGMAGICAL(valuesv))
        mg_get(valuesv);
    ST(0) = &PL_sv_yes;
    if (!dbd_st_STORE_attrib(sth, imp_sth, keysv, valuesv))
        if (!DBIc_DBISTATE(imp_sth)->set_attr(sth, keysv, valuesv))
            ST(0) = &PL_sv_no;
#line 1269 "Perl.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Perl__st_FETCH_attrib); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__st_FETCH_attrib)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "sth, keysv");
    {
	SV *	sth = ST(0);
	SV *	keysv = ST(1);
#line 737 "./Perl.xsi"
    D_imp_sth(sth);
    SV *valuesv;
    PERL_UNUSED_VAR(ix);
    valuesv = dbd_st_FETCH_attrib(sth, imp_sth, keysv);
    if (!valuesv)
        valuesv = DBIc_DBISTATE(imp_sth)->get_attr(sth, keysv);
    ST(0) = valuesv;    /* dbd_st_FETCH_attrib did sv_2mortal   */
#line 1297 "Perl.c"
    }
    XSRETURN(1);
}


XS(XS_DBD__Perl__st_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__st_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	sth = ST(0);
#line 750 "./Perl.xsi"
    /* keep in sync with default DESTROY in DBI.xs */
    D_imp_sth(sth);
    ST(0) = &PL_sv_yes;
    if (!DBIc_IMPSET(imp_sth)) {        /* was never fully set up       */
        STRLEN lna;
        if (DBIc_WARN(imp_sth) && !PL_dirty && DBIc_DBISTATE(imp_sth)->debug >= 2)
             PerlIO_printf(DBIc_LOGPIO(imp_sth),
                "         DESTROY for %s ignored - handle not initialised\n",
                    SvPV(sth,lna));
    }
    else {
        if (DBIc_IADESTROY(imp_sth)) {  /* wants ineffective destroy    */
            DBIc_ACTIVE_off(imp_sth);
            if (DBIc_DBISTATE(imp_sth)->debug)
                 PerlIO_printf(DBIc_LOGPIO(imp_sth), "         DESTROY %s skipped due to InactiveDestroy\n", SvPV_nolen(sth));
        }
        if (DBIc_ACTIVE(imp_sth)) {
            D_imp_dbh_from_sth;
            if (!PL_dirty && DBIc_ACTIVE(imp_dbh)) {
#ifdef dbd_st_finish3
                dbd_st_finish3(sth, imp_sth, 1);
#else
                dbd_st_finish(sth, imp_sth);
#endif
            }
            else {
                DBIc_ACTIVE_off(imp_sth);
            }
        }
        dbd_st_destroy(sth, imp_sth);
    }
#line 1349 "Perl.c"
	PUTBACK;
	return;
    }
}


/* INCLUDE: Returning to 'Perl.xs' from 'Perl.xsi' */

#ifdef __cplusplus
extern "C"
#endif
XS(boot_DBD__Perl); /* prototype to pass -Wmissing-prototypes */
XS(boot_DBD__Perl)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK ;

    {
        CV * cv ;

        newXS("DBD::Perl::dr::dbixs_revision", XS_DBD__Perl__dr_dbixs_revision, file);
#if XSubPPtmpAAAA
        cv = newXS("DBD::Perl::dr::discon_all_", XS_DBD__Perl__dr_discon_all_, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("DBD::Perl::dr::disconnect_all", XS_DBD__Perl__dr_discon_all_, file);
        XSANY.any_i32 = 1 ;
#endif
#if XSubPPtmpAAAB
        newXS("DBD::Perl::dr::data_sources", XS_DBD__Perl__dr_data_sources, file);
#endif
        newXS("DBD::Perl::db::_login", XS_DBD__Perl__db__login, file);
        newXS("DBD::Perl::db::selectall_arrayref", XS_DBD__Perl__db_selectall_arrayref, file);
        cv = newXS("DBD::Perl::db::selectrow_array", XS_DBD__Perl__db_selectrow_arrayref, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("DBD::Perl::db::selectrow_arrayref", XS_DBD__Perl__db_selectrow_arrayref, file);
        XSANY.any_i32 = 0 ;
#if XSubPPtmpAAAC
        newXS("DBD::Perl::db::do", XS_DBD__Perl__db_do, file);
#endif
#if XSubPPtmpAAAD
        newXS("DBD::Perl::db::last_insert_id", XS_DBD__Perl__db_last_insert_id, file);
#endif
        newXS("DBD::Perl::db::commit", XS_DBD__Perl__db_commit, file);
        newXS("DBD::Perl::db::rollback", XS_DBD__Perl__db_rollback, file);
        newXS("DBD::Perl::db::disconnect", XS_DBD__Perl__db_disconnect, file);
        newXS("DBD::Perl::db::STORE", XS_DBD__Perl__db_STORE, file);
        newXS("DBD::Perl::db::FETCH", XS_DBD__Perl__db_FETCH, file);
        newXS("DBD::Perl::db::DESTROY", XS_DBD__Perl__db_DESTROY, file);
#if XSubPPtmpAAAE
        newXS("DBD::Perl::db::take_imp_data", XS_DBD__Perl__db_take_imp_data, file);
#endif
#if XSubPPtmpAAAF
        newXS("DBD::Perl::db::data_sources", XS_DBD__Perl__db_data_sources, file);
#endif
        newXS("DBD::Perl::st::_prepare", XS_DBD__Perl__st__prepare, file);
#if XSubPPtmpAAAG
        newXS("DBD::Perl::st::rows", XS_DBD__Perl__st_rows, file);
#endif
#if XSubPPtmpAAAH
        newXS("DBD::Perl::st::bind_col", XS_DBD__Perl__st_bind_col, file);
#endif
        newXS("DBD::Perl::st::bind_param", XS_DBD__Perl__st_bind_param, file);
        newXS("DBD::Perl::st::bind_param_inout", XS_DBD__Perl__st_bind_param_inout, file);
        newXS("DBD::Perl::st::execute", XS_DBD__Perl__st_execute, file);
#if XSubPPtmpAAAI
        newXS("DBD::Perl::st::execute_for_fetch", XS_DBD__Perl__st_execute_for_fetch, file);
#endif
        cv = newXS("DBD::Perl::st::fetch", XS_DBD__Perl__st_fetchrow_arrayref, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("DBD::Perl::st::fetchrow_arrayref", XS_DBD__Perl__st_fetchrow_arrayref, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("DBD::Perl::st::fetchrow_array", XS_DBD__Perl__st_fetchrow_array, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("DBD::Perl::st::fetchrow", XS_DBD__Perl__st_fetchrow_array, file);
        XSANY.any_i32 = 1 ;
        newXS("DBD::Perl::st::fetchall_arrayref", XS_DBD__Perl__st_fetchall_arrayref, file);
        newXS("DBD::Perl::st::finish", XS_DBD__Perl__st_finish, file);
        newXS("DBD::Perl::st::blob_read", XS_DBD__Perl__st_blob_read, file);
        newXS("DBD::Perl::st::STORE", XS_DBD__Perl__st_STORE, file);
        cv = newXS("DBD::Perl::st::FETCH_attrib", XS_DBD__Perl__st_FETCH_attrib, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("DBD::Perl::st::FETCH", XS_DBD__Perl__st_FETCH_attrib, file);
        XSANY.any_i32 = 1 ;
        newXS("DBD::Perl::st::DESTROY", XS_DBD__Perl__st_DESTROY, file);
    }

    /* Initialisation Section */

#line 18 "./Perl.xsi"
    PERL_UNUSED_VAR(items);
    DBISTATE_INIT;
    /* XXX this interface will change: */
    DBI_IMP_SIZE("DBD::Perl::dr::imp_data_size", sizeof(imp_drh_t));
    DBI_IMP_SIZE("DBD::Perl::db::imp_data_size", sizeof(imp_dbh_t));
    DBI_IMP_SIZE("DBD::Perl::st::imp_data_size", sizeof(imp_sth_t));
    dbd_init(DBIS);

#if XSubPPtmpAAAA
#endif
#if XSubPPtmpAAAB
#endif
#if XSubPPtmpAAAC
#endif
#if XSubPPtmpAAAD
#endif
#if XSubPPtmpAAAE
#endif
#if XSubPPtmpAAAF
#endif
#if XSubPPtmpAAAG
#endif
#if XSubPPtmpAAAH
#endif
#if XSubPPtmpAAAI
#endif
#line 1480 "Perl.c"

    /* End of Initialisation Section */

#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

