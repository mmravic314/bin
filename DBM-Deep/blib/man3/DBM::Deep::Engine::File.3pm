.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBM::Deep::Engine::File 3pm"
.TH DBM::Deep::Engine::File 3pm "2014-01-12" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBM::Deep::Engine::File \- engine for use with DBM::Deep::Storage::File
.SH "PURPOSE"
.IX Header "PURPOSE"
This is the engine for use with DBM::Deep::Storage::File.
.SH "EXTERNAL METHODS"
.IX Header "EXTERNAL METHODS"
.SS "\fInew()\fP"
.IX Subsection "new()"
This takes a set of args. These args are described in the documentation for
\&\*(L"new\*(R" in DBM::Deep.
.SH "INTERNAL METHODS"
.IX Header "INTERNAL METHODS"
The following methods are internal-use-only to DBM::Deep::Engine::File.
.SS "\fIread_txn_slots()\fP"
.IX Subsection "read_txn_slots()"
This takes no arguments.
.PP
This will return an array with a 1 or 0 in each slot. Each spot represents one
available transaction. If the slot is 1, that transaction is taken. If it is 0,
the transaction is available.
.ie n .SS "write_txn_slots( @slots )"
.el .SS "write_txn_slots( \f(CW@slots\fP )"
.IX Subsection "write_txn_slots( @slots )"
This takes an array of 1's and 0's. This array represents the transaction slots
returned by \*(L"\fIread_txn_slots()\fR\*(R". In other words, the following is true:
.PP
.Vb 1
\&  @x = read_txn_slots( write_txn_slots( @x ) );
.Ve
.PP
(With the obviously missing object referents added back in.)
.SS "\fIget_running_txn_ids()\fP"
.IX Subsection "get_running_txn_ids()"
This takes no arguments.
.PP
This will return an array of taken transaction IDs. This wraps \*(L"\fIread_txn_slots()\fR\*(R".
.ie n .SS "get_txn_staleness_counter( $trans_id )"
.el .SS "get_txn_staleness_counter( \f(CW$trans_id\fP )"
.IX Subsection "get_txn_staleness_counter( $trans_id )"
This will return the staleness counter for the given transaction \s-1ID\s0. Please see
\&\*(L"\s-1STALENESS\s0\*(R" in DBM::Deep::Engine for more information.
.ie n .SS "inc_txn_staleness_counter( $trans_id )"
.el .SS "inc_txn_staleness_counter( \f(CW$trans_id\fP )"
.IX Subsection "inc_txn_staleness_counter( $trans_id )"
This will increment the staleness counter for the given transaction \s-1ID\s0. Please see
\&\*(L"\s-1STALENESS\s0\*(R" in DBM::Deep::Engine for more information.
.SS "\fIget_entries()\fP"
.IX Subsection "get_entries()"
This takes no arguments.
.PP
This returns a list of all the sectors that have been modified by this transaction.
.ie n .SS "add_entry( $trans_id, $location )"
.el .SS "add_entry( \f(CW$trans_id\fP, \f(CW$location\fP )"
.IX Subsection "add_entry( $trans_id, $location )"
This takes a transaction \s-1ID\s0 and a file location and marks the sector at that
location as having been modified by the transaction identified by \f(CW$trans_id\fR.
.PP
This returns nothing.
.PP
\&\fB\s-1NOTE\s0\fR: Unlike all the other \fI_entries()\fR methods, there are several cases where
\&\f(CW\*(C`$trans_id != $self\->trans_id\*(C'\fR for this method.
.ie n .SS "reindex_entry( $old_loc, $new_loc )"
.el .SS "reindex_entry( \f(CW$old_loc\fP, \f(CW$new_loc\fP )"
.IX Subsection "reindex_entry( $old_loc, $new_loc )"
This takes two locations (old and new, respectively). If a location that has
been modified by this transaction is subsequently reindexed due to a bucketlist
overflowing, then the entries hash needs to be made aware of this change.
.PP
This returns nothing.
.SS "\fIclear_entries()\fP"
.IX Subsection "clear_entries()"
This takes no arguments. It will clear the entries list for the running
transaction.
.PP
This returns nothing.
.SS "\fI_write_file_header()\fP"
.IX Subsection "_write_file_header()"
This writes the file header for a new file. This will write the various settings
that set how the file is interpreted.
.SS "\fI_read_file_header()\fP"
.IX Subsection "_read_file_header()"
This reads the file header from an existing file. This will read the various
settings that set how the file is interpreted.
.ie n .SS "_apply_digest( @stuff )"
.el .SS "_apply_digest( \f(CW@stuff\fP )"
.IX Subsection "_apply_digest( @stuff )"
This will apply the digest method (default to Digest::MD5::md5) to the arguments
passed in and return the result.
.ie n .SS "_add_free_blist_sector( $offset, $size )"
.el .SS "_add_free_blist_sector( \f(CW$offset\fP, \f(CW$size\fP )"
.IX Subsection "_add_free_blist_sector( $offset, $size )"
.ie n .SS "_add_free_data_sector( $offset, $size )"
.el .SS "_add_free_data_sector( \f(CW$offset\fP, \f(CW$size\fP )"
.IX Subsection "_add_free_data_sector( $offset, $size )"
.ie n .SS "_add_free_index_sector( $offset, $size )"
.el .SS "_add_free_index_sector( \f(CW$offset\fP, \f(CW$size\fP )"
.IX Subsection "_add_free_index_sector( $offset, $size )"
These methods are all wrappers around \fI_add_free_sector()\fR, providing the proper
chain offset ($multiple) for the sector type.
.ie n .SS "_add_free_sector( $multiple, $offset, $size )"
.el .SS "_add_free_sector( \f(CW$multiple\fP, \f(CW$offset\fP, \f(CW$size\fP )"
.IX Subsection "_add_free_sector( $multiple, $offset, $size )"
\&\fI_add_free_sector()\fR takes the offset into the chains location, the offset of the
sector, and the size of that sector. It will mark the sector as a free sector
and put it into the list of sectors that are free of this type for use later.
.PP
This returns nothing.
.PP
\&\fB\s-1NOTE\s0\fR: \f(CW$size\fR is unused?
.ie n .SS "_request_blist_sector( $size )"
.el .SS "_request_blist_sector( \f(CW$size\fP )"
.IX Subsection "_request_blist_sector( $size )"
.ie n .SS "_request_data_sector( $size )"
.el .SS "_request_data_sector( \f(CW$size\fP )"
.IX Subsection "_request_data_sector( $size )"
.ie n .SS "_request_index_sector( $size )"
.el .SS "_request_index_sector( \f(CW$size\fP )"
.IX Subsection "_request_index_sector( $size )"
These methods are all wrappers around \fI_request_sector()\fR, providing the proper
chain offset ($multiple) for the sector type.
.ie n .SS "_request_sector( $multiple $size )"
.el .SS "_request_sector( \f(CW$multiple\fP \f(CW$size\fP )"
.IX Subsection "_request_sector( $multiple $size )"
This takes the offset into the chains location and the size of that sector.
.PP
This returns the object with the sector. If there is an available free sector of
that type, then it will be reused. If there isn't one, then a new one will be
allocated.
.SS "\s-1ACCESSORS\s0"
.IX Subsection "ACCESSORS"
The following are readonly attributes.
.IP "\(bu" 4
byte_size
.IP "\(bu" 4
hash_size
.IP "\(bu" 4
hash_chars
.IP "\(bu" 4
num_txns
.IP "\(bu" 4
max_buckets
.IP "\(bu" 4
blank_md5
.IP "\(bu" 4
data_sector_size
.IP "\(bu" 4
txn_bitfield_len
.PP
The following are read/write attributes.
.IP "\(bu" 4
trans_id / set_trans_id( \f(CW$new_id\fR )
.IP "\(bu" 4
trans_loc / set_trans_loc( \f(CW$new_loc\fR )
.IP "\(bu" 4
chains_loc / set_chains_loc( \f(CW$new_loc\fR )
.SS "\fI_dump_file()\fP"
.IX Subsection "_dump_file()"
This method takes no arguments. It's used to print out a textual representation
of the DBM::Deep \s-1DB\s0 file. It assumes the file is not-corrupted.
