.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBM::Deep::Storage::File 3pm"
.TH DBM::Deep::Storage::File 3pm "2014-01-12" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBM::Deep::Storage::File \- mediate low\-level interaction with storage mechanism
.SH "PURPOSE"
.IX Header "PURPOSE"
This is an internal-use-only object for DBM::Deep. It mediates the low-level
interaction with the storage mechanism.
.PP
Currently, the only storage mechanism supported is the file system.
.SH "OVERVIEW"
.IX Header "OVERVIEW"
This class provides an abstraction to the storage mechanism so that the Engine
(the only class that uses this class) doesn't have to worry about that.
.SH "METHODS"
.IX Header "METHODS"
.SS "new( \e%args )"
.IX Subsection "new( %args )"
.SS "\fIopen()\fP"
.IX Subsection "open()"
This method opens the filehandle for the filename in \f(CW\*(C` file \*(C'\fR.
.PP
There is no return value.
.SS "\fIclose()\fP"
.IX Subsection "close()"
If the filehandle is opened, this will close it.
.PP
There is no return value.
.SS "\fIsize()\fP"
.IX Subsection "size()"
This will return the size of the \s-1DB\s0. If file_offset is set, this will take that into account.
.PP
\&\fB\s-1NOTE\s0\fR: This function isn't used internally anywhere.
.SS "\fIset_inode()\fP"
.IX Subsection "set_inode()"
This will set the inode value of the underlying file object.
.PP
This is only needed to handle some obscure Win32 bugs. It really shouldn't be
needed outside this object.
.PP
There is no return value.
.ie n .SS "print_at( $offset, @data )"
.el .SS "print_at( \f(CW$offset\fP, \f(CW@data\fP )"
.IX Subsection "print_at( $offset, @data )"
This takes an optional offset and some data to print.
.PP
\&\f(CW $offset \fR, if defined, will be used to seek into the file. If file_offset is
set, it will be used as the zero location. If it is undefined, no seeking will
occur. Then, \f(CW @data \fR will be printed to the current location.
.PP
There is no return value.
.ie n .SS "read_at( $offset, $length )"
.el .SS "read_at( \f(CW$offset\fP, \f(CW$length\fP )"
.IX Subsection "read_at( $offset, $length )"
This takes an optional offset and a length.
.PP
\&\f(CW $offset \fR, if defined, will be used to seek into the file. If file_offset is
set, it will be used as the zero location. If it is undefined, no seeking will
occur. Then, \f(CW $length \fR bytes will be read from the current location.
.PP
The data read will be returned.
.SS "\s-1DESTROY\s0"
.IX Subsection "DESTROY"
When the ::Storage::File object goes out of scope, it will be closed.
.ie n .SS "request_space( $size )"
.el .SS "request_space( \f(CW$size\fP )"
.IX Subsection "request_space( $size )"
This takes a size and adds that much space to the \s-1DBM\s0.
.PP
This returns the offset for the new location.
.ie n .SS "copy_stats( $target_filename )"
.el .SS "copy_stats( \f(CW$target_filename\fP )"
.IX Subsection "copy_stats( $target_filename )"
This will take the stats for the current filehandle and apply them to
\&\f(CW $target_filename \fR. The stats copied are:
.IP "\(bu" 4
Onwer \s-1UID\s0 and \s-1GID\s0
.IP "\(bu" 4
Permissions
