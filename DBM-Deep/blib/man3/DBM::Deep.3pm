.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBM::Deep 3pm"
.TH DBM::Deep 3pm "2014-01-12" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBM::Deep \- A pure perl multi\-level hash/array DBM that supports transactions
.SH "VERSION"
.IX Header "VERSION"
2.0011
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use DBM::Deep;
\&  my $db = DBM::Deep\->new( "foo.db" );
\&
\&  $db\->{key} = \*(Aqvalue\*(Aq;
\&  print $db\->{key};
\&
\&  $db\->put(\*(Aqkey\*(Aq => \*(Aqvalue\*(Aq);
\&  print $db\->get(\*(Aqkey\*(Aq);
\&
\&  # true multi\-level support
\&  $db\->{my_complex} = [
\&      \*(Aqhello\*(Aq, { perl => \*(Aqrules\*(Aq },
\&      42, 99,
\&  ];
\&
\&  $db\->begin_work;
\&
\&  # Do stuff here
\&
\&  $db\->rollback;
\&  $db\->commit;
\&
\&  tie my %db, \*(AqDBM::Deep\*(Aq, \*(Aqfoo.db\*(Aq;
\&  $db{key} = \*(Aqvalue\*(Aq;
\&  print $db{key};
\&
\&  tied(%db)\->put(\*(Aqkey\*(Aq => \*(Aqvalue\*(Aq);
\&  print tied(%db)\->get(\*(Aqkey\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A unique flat-file database module, written in pure perl. True multi-level
hash/array support (unlike \s-1MLDBM\s0, which is faked), hybrid \s-1OO\s0 / \fItie()\fR
interface, cross-platform FTPable files, \s-1ACID\s0 transactions, and is quite fast.
Can handle millions of keys and unlimited levels without significant
slow-down. Written from the ground-up in pure perl \*(-- this is \s-1NOT\s0 a wrapper
around a C\-based \s-1DBM\s0. Out-of-the-box compatibility with Unix, Mac \s-1OS\s0 X and
Windows.
.SH "VERSION DIFFERENCES"
.IX Header "VERSION DIFFERENCES"
\&\fB\s-1NOTE\s0\fR: 2.0000 introduces Unicode support in the File back end. This
necessitates a change in the file format. The version 1.0003 format is
still supported, though, so we have added a \fIdb_version()\fR
method. If you are using a database in the old format, you will have to
upgrade it to get Unicode support.
.PP
\&\fB\s-1NOTE\s0\fR: 1.0020 introduces different engines which are backed by different types
of storage. There is the original storage (called 'File') and a database storage
(called '\s-1DBI\s0'). q.v. \*(L"\s-1PLUGINS\s0\*(R" for more information.
.PP
\&\fB\s-1NOTE\s0\fR: 1.0000 has significant file format differences from prior versions.
There is a backwards-compatibility layer at \f(CW\*(C`utils/upgrade_db.pl\*(C'\fR. Files
created by 1.0000 or higher are \fB\s-1NOT\s0\fR compatible with scripts using prior
versions.
.SH "PLUGINS"
.IX Header "PLUGINS"
DBM::Deep is a wrapper around different storage engines. These are:
.SS "File"
.IX Subsection "File"
This is the traditional storage engine, storing the data to a custom file
format. The parameters accepted are:
.IP "\(bu" 4
file
.Sp
Filename of the \s-1DB\s0 file to link the handle to. You can pass a full absolute
filesystem path, partial path, or a plain filename if the file is in the
current working directory. This is a required parameter (though q.v. fh).
.IP "\(bu" 4
fh
.Sp
If you want, you can pass in the fh instead of the file. This is most useful for
doing something like:
.Sp
.Vb 1
\&  my $db = DBM::Deep\->new( { fh => \e*DATA } );
.Ve
.Sp
You are responsible for making sure that the fh has been opened appropriately
for your needs. If you open it read-only and attempt to write, an exception will
be thrown. If you open it write-only or append-only, an exception will be thrown
immediately as DBM::Deep needs to read from the fh.
.IP "\(bu" 4
file_offset
.Sp
This is the offset within the file that the DBM::Deep db starts. Most of the
time, you will not need to set this. However, it's there if you want it.
.Sp
If you pass in fh and do not set this, it will be set appropriately.
.IP "\(bu" 4
locking
.Sp
Specifies whether locking is to be enabled. DBM::Deep uses Perl's \fIflock()\fR
function to lock the database in exclusive mode for writes, and shared mode
for reads. Pass any true value to enable. This affects the base \s-1DB\s0 handle
\&\fIand any child hashes or arrays\fR that use the same \s-1DB\s0 file. This is an
optional parameter, and defaults to 1 (enabled). See \*(L"\s-1LOCKING\s0\*(R" below for
more.
.PP
When you open an existing database file, the version of the database format
will stay the same. But if you are creating a new file, it will be in the
latest format.
.SS "\s-1DBI\s0"
.IX Subsection "DBI"
This is a storage engine that stores the data in a relational database. Funnily
enough, this engine doesn't work with transactions (yet) as InnoDB doesn't do
what DBM::Deep needs it to do.
.PP
The parameters accepted are:
.IP "\(bu" 4
dbh
.Sp
This is a \s-1DBH\s0 that's already been opened with \*(L"connect\*(R" in \s-1DBI\s0.
.IP "\(bu" 4
dbi
.Sp
This is a hashref containing:
.RS 4
.IP "\(bu" 4
dsn
.IP "\(bu" 4
username
.IP "\(bu" 4
password
.IP "\(bu" 4
connect_args
.RE
.RS 4
.Sp
These correspond to the 4 parameters \*(L"connect\*(R" in \s-1DBI\s0 takes.
.RE
.PP
\&\fB\s-1NOTE\s0\fR: This has only been tested with MySQL and SQLite (with
disappointing results). I plan on extending this to work with PostgreSQL in
the near future. Oracle, Sybase, and other engines will come later.
.SS "Planned engines"
.IX Subsection "Planned engines"
There are plans to extend this functionality to (at least) the following:
.IP "\(bu" 4
\&\s-1BDB\s0 (and other hash engines like memcached)
.IP "\(bu" 4
NoSQL engines (such as Tokyo Cabinet)
.IP "\(bu" 4
DBIx::Class (and other ORMs)
.SH "SETUP"
.IX Header "SETUP"
Construction can be done OO-style (which is the recommended way), or using
Perl's \fItie()\fR function. Both are examined here.
.SS "\s-1OO\s0 Construction"
.IX Subsection "OO Construction"
The recommended way to construct a DBM::Deep object is to use the \fInew()\fR
method, which gets you a blessed \fIand\fR tied hash (or array) reference.
.PP
.Vb 1
\&  my $db = DBM::Deep\->new( "foo.db" );
.Ve
.PP
This opens a new database handle, mapped to the file \*(L"foo.db\*(R". If this
file does not exist, it will automatically be created. \s-1DB\s0 files are
opened in \*(L"r+\*(R" (read/write) mode, and the type of object returned is a
hash, unless otherwise specified (see \*(L"Options\*(R" below).
.PP
You can pass a number of options to the constructor to specify things like
locking, autoflush, etc. This is done by passing an inline hash (or hashref):
.PP
.Vb 5
\&  my $db = DBM::Deep\->new(
\&      file      => "foo.db",
\&      locking   => 1,
\&      autoflush => 1
\&  );
.Ve
.PP
Notice that the filename is now specified \fIinside\fR the hash with
the \*(L"file\*(R" parameter, as opposed to being the sole argument to the
constructor. This is required if any options are specified.
See \*(L"Options\*(R" below for the complete list.
.PP
You can also start with an array instead of a hash. For this, you must
specify the \f(CW\*(C`type\*(C'\fR parameter:
.PP
.Vb 4
\&  my $db = DBM::Deep\->new(
\&      file => "foo.db",
\&      type => DBM::Deep\->TYPE_ARRAY
\&  );
.Ve
.PP
\&\fBNote:\fR Specifying the \f(CW\*(C`type\*(C'\fR parameter only takes effect when beginning
a new \s-1DB\s0 file. If you create a DBM::Deep object with an existing file, the
\&\f(CW\*(C`type\*(C'\fR will be loaded from the file header, and an error will be thrown if
the wrong type is passed in.
.SS "Tie Construction"
.IX Subsection "Tie Construction"
Alternately, you can create a DBM::Deep handle by using Perl's built-in
\&\fItie()\fR function. The object returned from \fItie()\fR can be used to call methods,
such as \fIlock()\fR and \fIunlock()\fR. (That object can be retrieved from the tied
variable at any time using \fItied()\fR \- please see perltie for more info.)
.PP
.Vb 2
\&  my %hash;
\&  my $db = tie %hash, "DBM::Deep", "foo.db";
\&
\&  my @array;
\&  my $db = tie @array, "DBM::Deep", "bar.db";
.Ve
.PP
As with the \s-1OO\s0 constructor, you can replace the \s-1DB\s0 filename parameter with
a hash containing one or more options (see \*(L"Options\*(R" just below for the
complete list).
.PP
.Vb 5
\&  tie %hash, "DBM::Deep", {
\&      file => "foo.db",
\&      locking => 1,
\&      autoflush => 1
\&  };
.Ve
.SS "Options"
.IX Subsection "Options"
There are a number of options that can be passed in when constructing your
DBM::Deep objects. These apply to both the \s-1OO\-\s0 and tie\- based approaches.
.IP "\(bu" 4
type
.Sp
This parameter specifies what type of object to create, a hash or array. Use
one of these two constants:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`DBM::Deep\->TYPE_HASH\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`DBM::Deep\->TYPE_ARRAY\*(C'\fR
.RE
.RS 4
.Sp
This only takes effect when beginning a new file. This is an optional
parameter, and defaults to \f(CW\*(C`DBM::Deep\->TYPE_HASH\*(C'\fR.
.RE
.IP "\(bu" 4
autoflush
.Sp
Specifies whether autoflush is to be enabled on the underlying filehandle.
This obviously slows down write operations, but is required if you may have
multiple processes accessing the same \s-1DB\s0 file (also consider enable \fIlocking\fR).
Pass any true value to enable. This is an optional parameter, and defaults to 1
(enabled).
.IP "\(bu" 4
filter_*
.Sp
See \*(L"\s-1FILTERS\s0\*(R" below.
.PP
The following parameters may be specified in the constructor the first time the
datafile is created. However, they will be stored in the header of the file and
cannot be overridden by subsequent openings of the file \- the values will be set
from the values stored in the datafile's header.
.IP "\(bu" 4
num_txns
.Sp
This is the number of transactions that can be running at one time. The
default is one \- the \s-1HEAD\s0. The minimum is one and the maximum is 255. The more
transactions, the larger and quicker the datafile grows.
.Sp
Simple access to a database, regardless of how many processes are doing it,
already counts as one transaction (the \s-1HEAD\s0). So, if you want, say, 5
processes to be able to call begin_work at the same time, \f(CW\*(C`num_txns\*(C'\fR must
be at least 6.
.Sp
See \*(L"\s-1TRANSACTIONS\s0\*(R" below.
.IP "\(bu" 4
max_buckets
.Sp
This is the number of entries that can be added before a reindexing. The larger
this number is made, the larger a file gets, but the better performance you will
have. The default and minimum number this can be is 16. The maximum is 256, but
more than 64 isn't recommended.
.IP "\(bu" 4
data_sector_size
.Sp
This is the size in bytes of a given data sector. Data sectors will chain, so
a value of any size can be stored. However, chaining is expensive in terms of
time. Setting this value to something close to the expected common length of
your scalars will improve your performance. If it is too small, your file will
have a lot of chaining. If it is too large, your file will have a lot of dead
space in it.
.Sp
The default for this is 64 bytes. The minimum value is 32 and the maximum is
256 bytes.
.Sp
\&\fBNote:\fR There are between 6 and 10 bytes taken up in each data sector for
bookkeeping. (It's 4 + the number of bytes in your \*(L"pack_size\*(R".) This is
included within the data_sector_size, thus the effective value is 6\-10 bytes
less than what you specified.
.Sp
\&\fBAnother note:\fR If your strings contain any characters beyond the byte
range, they will be encoded as \s-1UTF\-8\s0 before being stored in the file. This
will make all non-ASCII characters take up more than one byte each.
.IP "\(bu" 4
pack_size
.Sp
This is the size of the file pointer used throughout the file. The valid values
are:
.RS 4
.IP "\(bu" 4
small
.Sp
This uses 2\-byte offsets, allowing for a maximum file size of 65 \s-1KB\s0.
.IP "\(bu" 4
medium (default)
.Sp
This uses 4\-byte offsets, allowing for a maximum file size of 4 \s-1GB\s0.
.IP "\(bu" 4
large
.Sp
This uses 8\-byte offsets, allowing for a maximum file size of 16 \s-1XB\s0
(exabytes). This can only be enabled if your Perl is compiled for 64\-bit.
.RE
.RS 4
.Sp
See \*(L"\s-1LARGEFILE\s0 \s-1SUPPORT\s0\*(R" for more information.
.RE
.IP "\(bu" 4
external_refs
.Sp
This is a boolean option. When enabled, it allows external references to
database entries to hold on to those entries, even when they are deleted.
.Sp
To illustrate, if you retrieve a hash (or array) reference from the
database,
.Sp
.Vb 1
\&  $foo_hash = $db\->{foo};
.Ve
.Sp
the hash reference is still tied to the database. So if you
.Sp
.Vb 1
\&  delete $db\->{foo};
.Ve
.Sp
\&\f(CW$foo_hash\fR will point to a location in the \s-1DB\s0 that is no longer valid (we
call this a stale reference). So if you try to retrieve the data from
\&\f(CW$foo_hash\fR,
.Sp
.Vb 1
\&  for(keys %$foo_hash) {
.Ve
.Sp
you will get an error.
.Sp
The \f(CW\*(C`external_refs\*(C'\fR option causes \f(CW$foo_hash\fR to 'hang on' to the
\&\s-1DB\s0 entry, so it will not be deleted from the database if there is still a
reference to it in a running program. It will be deleted, instead, when the
\&\f(CW$foo_hash\fR variable no longer exists, or is overwritten.
.Sp
This has the potential to cause database bloat if your program crashes, so
it is not enabled by default. (See also the \*(L"export\*(R" method for an
alternative workaround.)
.SH "TIE INTERFACE"
.IX Header "TIE INTERFACE"
With DBM::Deep you can access your databases using Perl's standard hash/array
syntax. Because all DBM::Deep objects are \fItied\fR to hashes or arrays, you can
treat them as such (but see \*(L"external_refs\*(R", above, and
\&\*(L"Stale References\*(R", below). DBM::Deep will intercept
all reads/writes and direct them
to the right place \*(-- the \s-1DB\s0 file. This has nothing to do with the
\&\*(L"Tie Construction\*(R" section above. This simply tells you how to use DBM::Deep
using regular hashes and arrays, rather than calling functions like \f(CW\*(C`get()\*(C'\fR
and \f(CW\*(C`put()\*(C'\fR (although those work too). It is entirely up to you how to want
to access your databases.
.SS "Hashes"
.IX Subsection "Hashes"
You can treat any DBM::Deep object like a normal Perl hash reference. Add keys,
or even nested hashes (or arrays) using standard Perl syntax:
.PP
.Vb 1
\&  my $db = DBM::Deep\->new( "foo.db" );
\&
\&  $db\->{mykey} = "myvalue";
\&  $db\->{myhash} = {};
\&  $db\->{myhash}\->{subkey} = "subvalue";
\&
\&  print $db\->{myhash}\->{subkey} . "\en";
.Ve
.PP
You can even step through hash keys using the normal Perl \f(CW\*(C`keys()\*(C'\fR function:
.PP
.Vb 3
\&  foreach my $key (keys %$db) {
\&      print "$key: " . $db\->{$key} . "\en";
\&  }
.Ve
.PP
Remember that Perl's \f(CW\*(C`keys()\*(C'\fR function extracts \fIevery\fR key from the hash and
pushes them onto an array, all before the loop even begins. If you have an
extremely large hash, this may exhaust Perl's memory. Instead, consider using
Perl's \f(CW\*(C`each()\*(C'\fR function, which pulls keys/values one at a time, using very
little memory:
.PP
.Vb 3
\&  while (my ($key, $value) = each %$db) {
\&      print "$key: $value\en";
\&  }
.Ve
.PP
Please note that when using \f(CW\*(C`each()\*(C'\fR, you should always pass a direct
hash reference, not a lookup. Meaning, you should \fBnever\fR do this:
.PP
.Vb 2
\&  # NEVER DO THIS
\&  while (my ($key, $value) = each %{$db\->{foo}}) { # BAD
.Ve
.PP
This causes an infinite loop, because for each iteration, Perl is calling
\&\s-1\fIFETCH\s0()\fR on the \f(CW$db\fR handle, resulting in a \*(L"new\*(R" hash for foo every time, so
it effectively keeps returning the first key over and over again. Instead,
assign a temporary variable to \f(CW\*(C`$db\->{foo}\*(C'\fR, then pass that to \fIeach()\fR.
.SS "Arrays"
.IX Subsection "Arrays"
As with hashes, you can treat any DBM::Deep object like a normal Perl array
reference. This includes inserting, removing and manipulating elements,
and the \f(CW\*(C`push()\*(C'\fR, \f(CW\*(C`pop()\*(C'\fR, \f(CW\*(C`shift()\*(C'\fR, \f(CW\*(C`unshift()\*(C'\fR and \f(CW\*(C`splice()\*(C'\fR functions.
The object must have first been created using type
\&\f(CW\*(C`DBM::Deep\->TYPE_ARRAY\*(C'\fR,
or simply be a nested array reference inside a hash. Example:
.PP
.Vb 4
\&  my $db = DBM::Deep\->new(
\&      file => "foo\-array.db",
\&      type => DBM::Deep\->TYPE_ARRAY
\&  );
\&
\&  $db\->[0] = "foo";
\&  push @$db, "bar", "baz";
\&  unshift @$db, "bah";
\&
\&  my $last_elem   = pop @$db;   # baz
\&  my $first_elem  = shift @$db; # bah
\&  my $second_elem = $db\->[1];   # bar
\&
\&  my $num_elements = scalar @$db;
.Ve
.SH "OO INTERFACE"
.IX Header "OO INTERFACE"
In addition to the \fI\fItie()\fI\fR interface, you can also use a standard \s-1OO\s0 interface
to manipulate all aspects of DBM::Deep databases. Each type of object (hash or
array) has its own methods, but both types share the following common methods:
\&\f(CW\*(C`put()\*(C'\fR, \f(CW\*(C`get()\*(C'\fR, \f(CW\*(C`exists()\*(C'\fR, \f(CW\*(C`delete()\*(C'\fR and \f(CW\*(C`clear()\*(C'\fR. \f(CW\*(C`fetch()\*(C'\fR and
\&\f(CW\*(C`store()\*(C'\fR are aliases to \f(CW\*(C`put()\*(C'\fR and \f(CW\*(C`get()\*(C'\fR, respectively.
.IP "\(bu" 4
\&\fInew()\fR / \fIclone()\fR
.IX Xref "new clone"
.Sp
These are the constructor and copy-functions.
.IP "\(bu" 4
\&\fIput()\fR / \fIstore()\fR
.IX Xref "put store"
.Sp
Stores a new hash key/value pair, or sets an array element value. Takes two
arguments, the hash key or array index, and the new value. The value can be
a scalar, hash ref or array ref. Returns true on success, false on failure.
.Sp
.Vb 2
\&  $db\->put("foo", "bar"); # for hashes
\&  $db\->put(1, "bar"); # for arrays
.Ve
.IP "\(bu" 4
\&\fIget()\fR / \fIfetch()\fR
.IX Xref "get fetch"
.Sp
Fetches the value of a hash key or array element. Takes one argument: the hash
key or array index. Returns a scalar, hash ref or array ref, depending on the
data type stored.
.Sp
.Vb 2
\&  my $value = $db\->get("foo"); # for hashes
\&  my $value = $db\->get(1); # for arrays
.Ve
.IP "\(bu" 4
\&\fIexists()\fR
.IX Xref "exists"
.Sp
Checks if a hash key or array index exists. Takes one argument: the hash key
or array index. Returns true if it exists, false if not.
.Sp
.Vb 2
\&  if ($db\->exists("foo")) { print "yay!\en"; } # for hashes
\&  if ($db\->exists(1)) { print "yay!\en"; } # for arrays
.Ve
.IP "\(bu" 4
\&\fIdelete()\fR
.IX Xref "delete"
.Sp
Deletes one hash key/value pair or array element. Takes one argument: the hash
key or array index. Returns the data that the element used to contain (just
like Perl's \f(CW\*(C`delete\*(C'\fR function), which is \f(CW\*(C`undef\*(C'\fR if it did not exist. For
arrays, the remaining elements located after the deleted element are \s-1NOT\s0
moved over. The deleted element is essentially just undefined, which is
exactly how Perl's
internal arrays work.
.Sp
.Vb 2
\&  $db\->delete("foo"); # for hashes
\&  $db\->delete(1); # for arrays
.Ve
.IP "\(bu" 4
\&\fIclear()\fR
.IX Xref "clear"
.Sp
Deletes \fBall\fR hash keys or array elements. Takes no arguments. No return
value.
.Sp
.Vb 1
\&  $db\->clear(); # hashes or arrays
.Ve
.IP "\(bu" 4
\&\fIlock()\fR / \fIunlock()\fR / \fIlock_exclusive()\fR / \fIlock_shared()\fR
.IX Xref "lock unlock lock_exclusive lock_shared"
.Sp
q.v. \*(L"\s-1LOCKING\s0\*(R" for more info.
.IP "\(bu" 4
\&\fIoptimize()\fR
.IX Xref "optimize"
.Sp
This will compress the datafile so that it takes up as little space as possible.
There is a freespace manager so that when space is freed up, it is used before
extending the size of the datafile. But, that freespace just sits in the
datafile unless \f(CW\*(C`optimize()\*(C'\fR is called.
.Sp
\&\f(CW\*(C`optimize\*(C'\fR basically copies everything into a new database, so, if it is
in version 1.0003 format, it will be upgraded.
.IP "\(bu" 4
\&\fIimport()\fR
.IX Xref "import"
.Sp
Unlike simple assignment, \f(CW\*(C`import()\*(C'\fR does not tie the right-hand side. Instead,
a copy of your data is put into the \s-1DB\s0. \f(CW\*(C`import()\*(C'\fR takes either an arrayref (if
your \s-1DB\s0 is an array) or a hashref (if your \s-1DB\s0 is a hash). \f(CW\*(C`import()\*(C'\fR will die
if anything else is passed in.
.IP "\(bu" 4
\&\fIexport()\fR
.IX Xref "export"
.Sp
This returns a complete copy of the data structure at the point you do the export.
This copy is in \s-1RAM\s0, not on disk like the \s-1DB\s0 is.
.IP "\(bu" 4
\&\fIbegin_work()\fR / \fIcommit()\fR / \fIrollback()\fR
.Sp
These are the transactional functions. \*(L"\s-1TRANSACTIONS\s0\*(R" for more information.
.IP "\(bu" 4
supports( \f(CW$option\fR )
.IX Xref "supports"
.Sp
This returns a boolean indicating whether this instance of DBM::Deep
supports that feature. \f(CW$option\fR can be one of:
.RS 4
.IP "\(bu" 4
transactions
.IX Xref "translation"
.IP "\(bu" 4
unicode
.IX Xref "unicode"
.RE
.RS 4
.RE
.IP "\(bu" 4
\&\fIdb_version()\fR
.IX Xref "db_version"
.Sp
This returns the version of the database format that the current database
is in. This is specified as the earliest version of DBM::Deep that supports
it.
.Sp
For the File back end, this will be 1.0003 or 2.
.Sp
For the \s-1DBI\s0 back end, it is currently always 1.0020.
.SS "Hashes"
.IX Subsection "Hashes"
For hashes, DBM::Deep supports all the common methods described above, and the
following additional methods: \f(CW\*(C`first_key()\*(C'\fR and \f(CW\*(C`next_key()\*(C'\fR.
.IP "\(bu" 4
\&\fIfirst_key()\fR
.IX Xref "first_key"
.Sp
Returns the \*(L"first\*(R" key in the hash. As with built-in Perl hashes, keys are
fetched in an undefined order (which appears random). Takes no arguments,
returns the key as a scalar value.
.Sp
.Vb 1
\&  my $key = $db\->first_key();
.Ve
.IP "\(bu" 4
\&\fInext_key()\fR
.IX Xref "next_key"
.Sp
Returns the \*(L"next\*(R" key in the hash, given the previous one as the sole argument.
Returns undef if there are no more keys to be fetched.
.Sp
.Vb 1
\&  $key = $db\->next_key($key);
.Ve
.PP
Here are some examples of using hashes:
.PP
.Vb 1
\&  my $db = DBM::Deep\->new( "foo.db" );
\&
\&  $db\->put("foo", "bar");
\&  print "foo: " . $db\->get("foo") . "\en";
\&
\&  $db\->put("baz", {}); # new child hash ref
\&  $db\->get("baz")\->put("buz", "biz");
\&  print "buz: " . $db\->get("baz")\->get("buz") . "\en";
\&
\&  my $key = $db\->first_key();
\&  while ($key) {
\&      print "$key: " . $db\->get($key) . "\en";
\&      $key = $db\->next_key($key);
\&  }
\&
\&  if ($db\->exists("foo")) { $db\->delete("foo"); }
.Ve
.SS "Arrays"
.IX Subsection "Arrays"
For arrays, DBM::Deep supports all the common methods described above, and the
following additional methods: \f(CW\*(C`length()\*(C'\fR, \f(CW\*(C`push()\*(C'\fR, \f(CW\*(C`pop()\*(C'\fR, \f(CW\*(C`shift()\*(C'\fR,
\&\f(CW\*(C`unshift()\*(C'\fR and \f(CW\*(C`splice()\*(C'\fR.
.IP "\(bu" 4
\&\fIlength()\fR
.IX Xref "length"
.Sp
Returns the number of elements in the array. Takes no arguments.
.Sp
.Vb 1
\&  my $len = $db\->length();
.Ve
.IP "\(bu" 4
\&\fIpush()\fR
.IX Xref "push"
.Sp
Adds one or more elements onto the end of the array. Accepts scalars, hash
refs or array refs. No return value.
.Sp
.Vb 1
\&  $db\->push("foo", "bar", {});
.Ve
.IP "\(bu" 4
\&\fIpop()\fR
.IX Xref "pop"
.Sp
Fetches the last element in the array, and deletes it. Takes no arguments.
Returns undef if array is empty. Returns the element value.
.Sp
.Vb 1
\&  my $elem = $db\->pop();
.Ve
.IP "\(bu" 4
\&\fIshift()\fR
.IX Xref "shift"
.Sp
Fetches the first element in the array, deletes it, then shifts all the
remaining elements over to take up the space. Returns the element value. This
method is not recommended with large arrays \*(-- see \*(L"Large Arrays\*(R" below for
details.
.Sp
.Vb 1
\&  my $elem = $db\->shift();
.Ve
.IP "\(bu" 4
\&\fIunshift()\fR
.IX Xref "unshift"
.Sp
Inserts one or more elements onto the beginning of the array, shifting all
existing elements over to make room. Accepts scalars, hash refs or array refs.
No return value. This method is not recommended with large arrays \*(-- see
<Large Arrays> below for details.
.Sp
.Vb 1
\&  $db\->unshift("foo", "bar", {});
.Ve
.IP "\(bu" 4
\&\fIsplice()\fR
.IX Xref "splice"
.Sp
Performs exactly like Perl's built-in function of the same name. See
\&\*(L"splice\*(R" in perlfunc for usage \*(-- it is too complicated to document here. This
method is not recommended with large arrays \*(-- see \*(L"Large Arrays\*(R" below for
details.
.PP
Here are some examples of using arrays:
.PP
.Vb 4
\&  my $db = DBM::Deep\->new(
\&      file => "foo.db",
\&      type => DBM::Deep\->TYPE_ARRAY
\&  );
\&
\&  $db\->push("bar", "baz");
\&  $db\->unshift("foo");
\&  $db\->put(3, "buz");
\&
\&  my $len = $db\->length();
\&  print "length: $len\en"; # 4
\&
\&  for (my $k=0; $k<$len; $k++) {
\&      print "$k: " . $db\->get($k) . "\en";
\&  }
\&
\&  $db\->splice(1, 2, "biz", "baf");
\&
\&  while (my $elem = shift @$db) {
\&      print "shifted: $elem\en";
\&  }
.Ve
.SH "LOCKING"
.IX Header "LOCKING"
Enable or disable automatic file locking by passing a boolean value to the
\&\f(CW\*(C`locking\*(C'\fR parameter when constructing your DBM::Deep object (see \*(L"\s-1SETUP\s0\*(R"
above).
.PP
.Vb 4
\&  my $db = DBM::Deep\->new(
\&      file => "foo.db",
\&      locking => 1
\&  );
.Ve
.PP
This causes DBM::Deep to \f(CW\*(C`flock()\*(C'\fR the underlying filehandle with exclusive
mode for writes, and shared mode for reads. This is required if you have
multiple processes accessing the same database file, to avoid file corruption.
Please note that \f(CW\*(C`flock()\*(C'\fR does \s-1NOT\s0 work for files over \s-1NFS\s0. See \*(L"\s-1DB\s0 over
\&\s-1NFS\s0\*(R" below for more.
.SS "Explicit Locking"
.IX Subsection "Explicit Locking"
You can explicitly lock a database, so it remains locked for multiple
actions. This is done by calling the \f(CW\*(C`lock_exclusive()\*(C'\fR method (for when you
want to write) or the \f(CW\*(C`lock_shared()\*(C'\fR method (for when you want to read).
This is particularly useful for things like counters, where the current value
needs to be fetched, then incremented, then stored again.
.PP
.Vb 5
\&  $db\->lock_exclusive();
\&  my $counter = $db\->get("counter");
\&  $counter++;
\&  $db\->put("counter", $counter);
\&  $db\->unlock();
\&
\&  # or...
\&
\&  $db\->lock_exclusive();
\&  $db\->{counter}++;
\&  $db\->unlock();
.Ve
.SS "Win32/Cygwin"
.IX Subsection "Win32/Cygwin"
Due to Win32 actually enforcing the read-only status of a shared lock, all
locks on Win32 and cygwin are exclusive. This is because of how autovivification
currently works. Hopefully, this will go away in a future release.
.SH "IMPORTING/EXPORTING"
.IX Header "IMPORTING/EXPORTING"
You can import existing complex structures by calling the \f(CW\*(C`import()\*(C'\fR method,
and export an entire database into an in-memory structure using the \f(CW\*(C`export()\*(C'\fR
method. Both are examined here.
.SS "Importing"
.IX Subsection "Importing"
Say you have an existing hash with nested hashes/arrays inside it. Instead of
walking the structure and adding keys/elements to the database as you go,
simply pass a reference to the \f(CW\*(C`import()\*(C'\fR method. This recursively adds
everything to an existing DBM::Deep object for you. Here is an example:
.PP
.Vb 9
\&  my $struct = {
\&      key1 => "value1",
\&      key2 => "value2",
\&      array1 => [ "elem0", "elem1", "elem2" ],
\&      hash1 => {
\&          subkey1 => "subvalue1",
\&          subkey2 => "subvalue2"
\&      }
\&  };
\&
\&  my $db = DBM::Deep\->new( "foo.db" );
\&  $db\->import( $struct );
\&
\&  print $db\->{key1} . "\en"; # prints "value1"
.Ve
.PP
This recursively imports the entire \f(CW$struct\fR object into \f(CW$db\fR, including
all nested hashes and arrays. If the DBM::Deep object contains existing data,
keys are merged with the existing ones, replacing if they already exist.
The \f(CW\*(C`import()\*(C'\fR method can be called on any database level (not just the base
level), and works with both hash and array \s-1DB\s0 types.
.PP
\&\fBNote:\fR Make sure your existing structure has no circular references in it.
These will cause an infinite loop when importing. There are plans to fix this
in a later release.
.SS "Exporting"
.IX Subsection "Exporting"
Calling the \f(CW\*(C`export()\*(C'\fR method on an existing DBM::Deep object will return
a reference to a new in-memory copy of the database. The export is done
recursively, so all nested hashes/arrays are all exported to standard Perl
objects. Here is an example:
.PP
.Vb 1
\&  my $db = DBM::Deep\->new( "foo.db" );
\&
\&  $db\->{key1} = "value1";
\&  $db\->{key2} = "value2";
\&  $db\->{hash1} = {};
\&  $db\->{hash1}\->{subkey1} = "subvalue1";
\&  $db\->{hash1}\->{subkey2} = "subvalue2";
\&
\&  my $struct = $db\->export();
\&
\&  print $struct\->{key1} . "\en"; # prints "value1"
.Ve
.PP
This makes a complete copy of the database in memory, and returns a reference
to it. The \f(CW\*(C`export()\*(C'\fR method can be called on any database level (not just
the base level), and works with both hash and array \s-1DB\s0 types. Be careful of
large databases \*(-- you can store a lot more data in a DBM::Deep object than an
in-memory Perl structure.
.PP
\&\fBNote:\fR Make sure your database has no circular references in it.
These will cause an infinite loop when exporting. There are plans to fix this
in a later release.
.SH "FILTERS"
.IX Header "FILTERS"
DBM::Deep has a number of hooks where you can specify your own Perl function
to perform filtering on incoming or outgoing data. This is a perfect
way to extend the engine, and implement things like real-time compression or
encryption. Filtering applies to the base \s-1DB\s0 level, and all child hashes /
arrays. Filter hooks can be specified when your DBM::Deep object is first
constructed, or by calling the \f(CW\*(C`set_filter()\*(C'\fR method at any time. There are
four available filter hooks.
.SS "\fIset_filter()\fP"
.IX Subsection "set_filter()"
This method takes two parameters \- the filter type and the filter subreference.
The four types are:
.IP "\(bu" 4
filter_store_key
.Sp
This filter is called whenever a hash key is stored. It
is passed the incoming key, and expected to return a transformed key.
.IP "\(bu" 4
filter_store_value
.Sp
This filter is called whenever a hash key or array element is stored. It
is passed the incoming value, and expected to return a transformed value.
.IP "\(bu" 4
filter_fetch_key
.Sp
This filter is called whenever a hash key is fetched (i.e. via
\&\f(CW\*(C`first_key()\*(C'\fR or \f(CW\*(C`next_key()\*(C'\fR). It is passed the transformed key,
and expected to return the plain key.
.IP "\(bu" 4
filter_fetch_value
.Sp
This filter is called whenever a hash key or array element is fetched.
It is passed the transformed value, and expected to return the plain value.
.PP
Here are the two ways to setup a filter hook:
.PP
.Vb 5
\&  my $db = DBM::Deep\->new(
\&      file => "foo.db",
\&      filter_store_value => \e&my_filter_store,
\&      filter_fetch_value => \e&my_filter_fetch
\&  );
\&
\&  # or...
\&
\&  $db\->set_filter( "store_value", \e&my_filter_store );
\&  $db\->set_filter( "fetch_value", \e&my_filter_fetch );
.Ve
.PP
Your filter function will be called only when dealing with \s-1SCALAR\s0 keys or
values. When nested hashes and arrays are being stored/fetched, filtering
is bypassed. Filters are called as static functions, passed a single \s-1SCALAR\s0
argument, and expected to return a single \s-1SCALAR\s0 value. If you want to
remove a filter, set the function reference to \f(CW\*(C`undef\*(C'\fR:
.PP
.Vb 1
\&  $db\->set_filter( "store_value", undef );
.Ve
.SS "Examples"
.IX Subsection "Examples"
Please read DBM::Deep::Cookbook for examples of filters.
.SH "ERROR HANDLING"
.IX Header "ERROR HANDLING"
Most DBM::Deep methods return a true value for success, and call \fIdie()\fR on
failure. You can wrap calls in an eval block to catch the die.
.PP
.Vb 2
\&  my $db = DBM::Deep\->new( "foo.db" ); # create hash
\&  eval { $db\->push("foo"); }; # ILLEGAL \-\- push is array\-only call
\&
\&  print $@;           # prints error message
.Ve
.SH "LARGEFILE SUPPORT"
.IX Header "LARGEFILE SUPPORT"
If you have a 64\-bit system, and your Perl is compiled with both \s-1LARGEFILE\s0
and 64\-bit support, you \fImay\fR be able to create databases larger than 4 \s-1GB\s0.
DBM::Deep by default uses 32\-bit file offset tags, but these can be changed
by specifying the 'pack_size' parameter when constructing the file.
.PP
.Vb 4
\&  DBM::Deep\->new(
\&      file      => $filename,
\&      pack_size => \*(Aqlarge\*(Aq,
\&  );
.Ve
.PP
This tells DBM::Deep to pack all file offsets with 8\-byte (64\-bit) quad words
instead of 32\-bit longs. After setting these values your \s-1DB\s0 files have a
theoretical maximum size of 16 \s-1XB\s0 (exabytes).
.PP
You can also use \f(CW\*(C`pack_size => \*(Aqsmall\*(Aq\*(C'\fR in order to use 16\-bit file
offsets.
.PP
\&\fBNote:\fR Changing these values will \fB\s-1NOT\s0\fR work for existing database files.
Only change this for new files. Once the value has been set, it is stored in
the file's header and cannot be changed for the life of the file. These
parameters are per-file, meaning you can access 32\-bit and 64\-bit files, as
you choose.
.PP
\&\fBNote:\fR We have not personally tested files larger than 4 \s-1GB\s0 \*(-- all our
systems have only a 32\-bit Perl. However, we have received user reports that
this does indeed work.
.SH "LOW-LEVEL ACCESS"
.IX Header "LOW-LEVEL ACCESS"
If you require low-level access to the underlying filehandle that DBM::Deep uses,
you can call the \f(CW\*(C`_fh()\*(C'\fR method, which returns the handle:
.PP
.Vb 1
\&  my $fh = $db\->_fh();
.Ve
.PP
This method can be called on the root level of the database, or any child
hashes or arrays. All levels share a \fIroot\fR structure, which contains things
like the filehandle, a reference counter, and all the options specified
when you created the object. You can get access to this file object by
calling the \f(CW\*(C`_storage()\*(C'\fR method.
.PP
.Vb 1
\&  my $file_obj = $db\->_storage();
.Ve
.PP
This is useful for changing options after the object has already been created,
such as enabling/disabling locking. You can also store your own temporary user
data in this structure (be wary of name collision), which is then accessible from
any child hash or array.
.SH "CIRCULAR REFERENCES"
.IX Header "CIRCULAR REFERENCES"
DBM::Deep has full support for circular references. Meaning you
can have a nested hash key or array element that points to a parent object.
This relationship is stored in the \s-1DB\s0 file, and is preserved between sessions.
Here is an example:
.PP
.Vb 1
\&  my $db = DBM::Deep\->new( "foo.db" );
\&
\&  $db\->{foo} = "bar";
\&  $db\->{circle} = $db; # ref to self
\&
\&  print $db\->{foo} . "\en"; # prints "bar"
\&  print $db\->{circle}\->{foo} . "\en"; # prints "bar" again
.Ve
.PP
This also works as expected with array and hash references. So, the following
works as expected:
.PP
.Vb 2
\&  $db\->{foo} = [ 1 .. 3 ];
\&  $db\->{bar} = $db\->{foo};
\&
\&  push @{$db\->{foo}}, 42;
\&  is( $db\->{bar}[\-1], 42 ); # Passes
.Ve
.PP
This, however, does \fInot\fR extend to assignments from one \s-1DB\s0 file to another.
So, the following will throw an error:
.PP
.Vb 2
\&  my $db1 = DBM::Deep\->new( "foo.db" );
\&  my $db2 = DBM::Deep\->new( "bar.db" );
\&
\&  $db1\->{foo} = [];
\&  $db2\->{foo} = $db1\->{foo}; # dies
.Ve
.PP
\&\fBNote\fR: Passing the object to a function that recursively walks the
object tree (such as \fIData::Dumper\fR or even the built-in \f(CW\*(C`optimize()\*(C'\fR or
\&\f(CW\*(C`export()\*(C'\fR methods) will result in an infinite loop. This will be fixed in
a future release by adding singleton support.
.SH "TRANSACTIONS"
.IX Header "TRANSACTIONS"
As of 1.0000, DBM::Deep has \s-1ACID\s0 transactions. Every DBM::Deep object is completely
transaction-ready \- it is not an option you have to turn on. You do have to
specify how many transactions may run simultaneously (q.v. \*(L"num_txns\*(R").
.PP
Three new methods have been added to support them. They are:
.IP "\(bu" 4
\&\fIbegin_work()\fR
.Sp
This starts a transaction.
.IP "\(bu" 4
\&\fIcommit()\fR
.Sp
This applies the changes done within the transaction to the mainline and ends
the transaction.
.IP "\(bu" 4
\&\fIrollback()\fR
.Sp
This discards the changes done within the transaction to the mainline and ends
the transaction.
.PP
Transactions in DBM::Deep are done using a variant of the \s-1MVCC\s0 method, the
same method used by the InnoDB MySQL engine.
.SH "MIGRATION"
.IX Header "MIGRATION"
As of 1.0000, the file format has changed. To aid in upgrades, a migration
script is provided within the \s-1CPAN\s0 distribution, called
\&\fIutils/upgrade_db.pl\fR.
.PP
\&\fB\s-1NOTE:\s0\fR This script is not installed onto your system because it carries a copy
of every version prior to the current version.
.PP
As of version 2.0000, databases created by old versions back to 1.0003 can
be read, but new features may not be available unless the database is
upgraded first.
.SH "TODO"
.IX Header "TODO"
The following are items that are planned to be added in future releases. These
are separate from the \*(L"\s-1CAVEATS\s0, \s-1ISSUES\s0 & \s-1BUGS\s0\*(R" below.
.SS "Sub-Transactions"
.IX Subsection "Sub-Transactions"
Right now, you cannot run a transaction within a transaction. Removing this
restriction is technically straightforward, but the combinatorial explosion of
possible usecases hurts my head. If this is something you want to see
immediately, please submit many testcases.
.SS "Caching"
.IX Subsection "Caching"
If a client is willing to assert upon opening the file that this process will be
the only consumer of that datafile, then there are a number of caching
possibilities that can be taken advantage of. This does, however, mean that
DBM::Deep is more vulnerable to losing data due to unflushed changes. It also
means a much larger in-memory footprint. As such, it's not clear exactly how
this should be done. Suggestions are welcome.
.SS "Ram-only"
.IX Subsection "Ram-only"
The techniques used in DBM::Deep simply require a seekable contiguous
datastore. This could just as easily be a large string as a file. By using
substr, the \s-1STM\s0 capabilities of DBM::Deep could be used within a
single-process. I have no idea how I'd specify this, though. Suggestions are
welcome.
.SS "Different contention resolution mechanisms"
.IX Subsection "Different contention resolution mechanisms"
Currently, the only contention resolution mechanism is last-write-wins. This
is the mechanism used by most RDBMSes and should be good enough for most uses.
For advanced uses of \s-1STM\s0, other contention mechanisms will be needed. If you
have an idea of how you'd like to see contention resolution in DBM::Deep,
please let me know.
.SH "CAVEATS, ISSUES & BUGS"
.IX Header "CAVEATS, ISSUES & BUGS"
This section describes all the known issues with DBM::Deep. These are issues
that are either intractable or depend on some feature within Perl working
exactly right. It you have found something that is not listed below, please
send an e\-mail to bug\-DBM\-Deep@rt.cpan.org <mailto:bug-DBM-Deep@rt.cpan.org>.
Likewise, if you think you know of a way around one of these issues, please
let me know.
.SS "References"
.IX Subsection "References"
(The following assumes a high level of Perl understanding, specifically of
references. Most users can safely skip this section.)
.PP
Currently, the only references supported are \s-1HASH\s0 and \s-1ARRAY\s0. The other reference
types (\s-1SCALAR\s0, \s-1CODE\s0, \s-1GLOB\s0, and \s-1REF\s0) cannot be supported for various reasons.
.IP "\(bu" 4
\&\s-1GLOB\s0
.Sp
These are things like filehandles and other sockets. They can't be supported
because it's completely unclear how DBM::Deep should serialize them.
.IP "\(bu" 4
\&\s-1SCALAR\s0 / \s-1REF\s0
.Sp
The discussion here refers to the following type of example:
.Sp
.Vb 2
\&  my $x = 25;
\&  $db\->{key1} = \e$x;
\&
\&  $x = 50;
\&
\&  # In some other process ...
\&
\&  my $val = ${ $db\->{key1} };
\&
\&  is( $val, 50, "What actually gets stored in the DB file?" );
.Ve
.Sp
The problem is one of synchronization. When the variable being referred to
changes value, the reference isn't notified, which is kind of the point of
references. This means that the new value won't be stored in the datafile for
other processes to read. There is no \s-1TIEREF\s0.
.Sp
It is theoretically possible to store references to values already within a
DBM::Deep object because everything already is synchronized, but the change to
the internals would be quite large. Specifically, DBM::Deep would have to tie
every single value that is stored. This would bloat the \s-1RAM\s0 footprint of
DBM::Deep at least twofold (if not more) and be a significant performance drain,
all to support a feature that has never been requested.
.IP "\(bu" 4
\&\s-1CODE\s0
.Sp
Data::Dump::Streamer provides a mechanism for serializing coderefs,
including saving off all closure state. This would allow for DBM::Deep to
store the code for a subroutine. Then, whenever the subroutine is read, the
code could be \f(CW\*(C`eval()\*(C'\fR'ed into being. However, just as for \s-1SCALAR\s0 and \s-1REF\s0,
that closure state may change without notifying the DBM::Deep object storing
the reference. Again, this would generally be considered a feature.
.SS "External references and transactions"
.IX Subsection "External references and transactions"
If you do \f(CW\*(C`my $x = $db\->{foo};\*(C'\fR, then start a transaction, \f(CW$x\fR will be
referencing the database from outside the transaction. A fix for this (and other
issues with how external references into the database) is being looked into. This
is the skipped set of tests in t/39_singletons.t and a related issue is the focus
of t/37_delete_edge_cases.t
.SS "File corruption"
.IX Subsection "File corruption"
The current level of error handling in DBM::Deep is minimal. Files \fIare\fR checked
for a 32\-bit signature when opened, but any other form of corruption in the
datafile can cause segmentation faults. DBM::Deep may try to \f(CW\*(C`seek()\*(C'\fR past
the end of a file, or get stuck in an infinite loop depending on the level and
type of corruption. File write operations are not checked for failure (for
speed), so if you happen to run out of disk space, DBM::Deep will probably fail in
a bad way. These things will be addressed in a later version of DBM::Deep.
.SS "\s-1DB\s0 over \s-1NFS\s0"
.IX Subsection "DB over NFS"
Beware of using DBM::Deep files over \s-1NFS\s0. DBM::Deep uses \fIflock()\fR, which works
well on local filesystems, but will \s-1NOT\s0 protect you from file corruption over
\&\s-1NFS\s0. I've heard about setting up your \s-1NFS\s0 server with a locking daemon, then
using \f(CW\*(C`lockf()\*(C'\fR to lock your files, but your mileage may vary there as well.
From what I understand, there is no real way to do it. However, if you need
access to the underlying filehandle in DBM::Deep for using some other kind of
locking scheme like \f(CW\*(C`lockf()\*(C'\fR, see the \*(L"LOW-LEVEL \s-1ACCESS\s0\*(R" section above.
.SS "Copying Objects"
.IX Subsection "Copying Objects"
Beware of copying tied objects in Perl. Very strange things can happen.
Instead, use DBM::Deep's \f(CW\*(C`clone()\*(C'\fR method which safely copies the object and
returns a new, blessed and tied hash or array to the same level in the \s-1DB\s0.
.PP
.Vb 1
\&  my $copy = $db\->clone();
.Ve
.PP
\&\fBNote\fR: Since \fIclone()\fR here is cloning the object, not the database location,
any modifications to either \f(CW$db\fR or \f(CW$copy\fR will be visible to both.
.SS "Stale References"
.IX Subsection "Stale References"
If you take a reference to an array or hash from the database, it is tied
to the database itself. This means that if the datum in question is
subsequently deleted from the database, the reference to it will point to
an invalid location and unpredictable things will happen if you try to use
it.
.PP
So a seemingly innocuous piece of code like this:
.PP
.Vb 1
\&  my %hash = %{ $db\->{some_hash} };
.Ve
.PP
can fail if another process deletes or clobbers \f(CW\*(C`$db\->{some_hash}\*(C'\fR
while the data are being extracted, since \f(CW\*(C`%{\ ...\ }\*(C'\fR is not atomic.
(This actually happened.) The solution is to lock the database before
reading the data:
.PP
.Vb 3
\&  $db\->lock_exclusive;
\&  my %hash = %{ $db\->{some_hash} };
\&  $db\->unlock;
.Ve
.PP
As of version 1.0024, if you assign a stale reference to a location
in the database, DBM::Deep will warn, if you have uninitialized warnings
enabled, and treat the stale reference as \f(CW\*(C`undef\*(C'\fR. An attempt to use a
stale reference as an array or hash reference will cause an error.
.SS "Large Arrays"
.IX Subsection "Large Arrays"
Beware of using \f(CW\*(C`shift()\*(C'\fR, \f(CW\*(C`unshift()\*(C'\fR or \f(CW\*(C`splice()\*(C'\fR with large arrays.
These functions cause every element in the array to move, which can be murder
on DBM::Deep, as every element has to be fetched from disk, then stored again in
a different location. This will be addressed in a future version.
.PP
This has been somewhat addressed so that the cost is constant, regardless of
what is stored at those locations. So, small arrays with huge data structures in
them are faster. But, large arrays are still large.
.SS "Writeonly Files"
.IX Subsection "Writeonly Files"
If you pass in a filehandle to \fInew()\fR, you may have opened it in either a
readonly or writeonly mode. \s-1STORE\s0 will verify that the filehandle is writable.
However, there doesn't seem to be a good way to determine if a filehandle is
readable. And, if the filehandle isn't readable, it's not clear what will
happen. So, don't do that.
.SS "Assignments Within Transactions"
.IX Subsection "Assignments Within Transactions"
The following will \fInot\fR work as one might expect:
.PP
.Vb 1
\&  my $x = { a => 1 };
\&
\&  $db\->begin_work;
\&  $db\->{foo} = $x;
\&  $db\->rollback;
\&
\&  is( $x\->{a}, 1 ); # This will fail!
.Ve
.PP
The problem is that the moment a reference used as the rvalue to a DBM::Deep
object's lvalue, it becomes tied itself. This is so that future changes to
\&\f(CW$x\fR can be tracked within the DBM::Deep file and is considered to be a
feature. By the time the rollback occurs, there is no knowledge that there had
been an \f(CW$x\fR or what memory location to assign an \f(CW\*(C`export()\*(C'\fR to.
.PP
\&\fB\s-1NOTE:\s0\fR This does not affect importing because imports do a walk over the
reference to be imported in order to explicitly leave it untied.
.SH "CODE COVERAGE"
.IX Header "CODE COVERAGE"
Devel::Cover is used to test the code coverage of the tests. Below is the
Devel::Cover report on this distribution's test suite.
.PP
.Vb 10
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\-
\&  File                           stmt   bran   cond    sub    pod   time  total
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\-
\&  blib/lib/DBM/Deep.pm          100.0   89.1   82.9  100.0  100.0   32.5   98.1
\&  blib/lib/DBM/Deep/Array.pm    100.0   94.4  100.0  100.0  100.0    5.2   98.8
\&  blib/lib/DBM/Deep/Engine.pm   100.0   92.9  100.0  100.0  100.0    7.4  100.0
\&  ...ib/DBM/Deep/Engine/DBI.pm   95.0   73.1  100.0  100.0  100.0    1.5   90.4
\&  ...b/DBM/Deep/Engine/File.pm   92.3   78.5   88.9  100.0  100.0    4.9   90.3
\&  blib/lib/DBM/Deep/Hash.pm     100.0  100.0  100.0  100.0  100.0    3.8  100.0
\&  .../lib/DBM/Deep/Iterator.pm  100.0    n/a    n/a  100.0  100.0    0.0  100.0
\&  .../DBM/Deep/Iterator/DBI.pm  100.0  100.0    n/a  100.0  100.0    1.2  100.0
\&  ...DBM/Deep/Iterator/File.pm   92.5   84.6    n/a  100.0   66.7    0.6   90.0
\&  ...erator/File/BucketList.pm  100.0   75.0    n/a  100.0   66.7    0.4   93.8
\&  ...ep/Iterator/File/Index.pm  100.0  100.0    n/a  100.0  100.0    0.2  100.0
\&  blib/lib/DBM/Deep/Null.pm      87.5    n/a    n/a   75.0    n/a    0.0   83.3
\&  blib/lib/DBM/Deep/Sector.pm    91.7    n/a    n/a   83.3    0.0    6.7   74.4
\&  ...ib/DBM/Deep/Sector/DBI.pm   96.8   83.3    n/a  100.0    0.0    1.0   89.8
\&  ...p/Sector/DBI/Reference.pm  100.0   95.5  100.0  100.0    0.0    2.2   91.2
\&  ...Deep/Sector/DBI/Scalar.pm  100.0  100.0    n/a  100.0    0.0    1.1   92.9
\&  ...b/DBM/Deep/Sector/File.pm   96.0   87.5  100.0   92.3   25.0    2.2   91.0
\&  ...Sector/File/BucketList.pm   98.2   85.7   83.3  100.0    0.0    3.3   89.4
\&  .../Deep/Sector/File/Data.pm  100.0    n/a    n/a  100.0    0.0    0.1   90.9
\&  ...Deep/Sector/File/Index.pm  100.0   80.0   33.3  100.0    0.0    0.8   83.1
\&  .../Deep/Sector/File/Null.pm  100.0  100.0    n/a  100.0    0.0    0.0   91.7
\&  .../Sector/File/Reference.pm  100.0   90.0   80.0  100.0    0.0    1.4   91.5
\&  ...eep/Sector/File/Scalar.pm   98.4   87.5    n/a  100.0    0.0    0.8   91.9
\&  blib/lib/DBM/Deep/Storage.pm  100.0    n/a    n/a  100.0  100.0    0.0  100.0
\&  ...b/DBM/Deep/Storage/DBI.pm   97.3   70.8    n/a  100.0   38.5    6.7   87.0
\&  .../DBM/Deep/Storage/File.pm   96.6   77.1   80.0   95.7  100.0   16.0   91.8
\&  Total                          99.3   85.2   84.9   99.8   63.3  100.0   97.6
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\-
.Ve
.SH "MORE INFORMATION"
.IX Header "MORE INFORMATION"
Check out the DBM::Deep Google Group at http://groups.google.com/group/DBM\-Deep <http://groups.google.com/group/DBM-Deep>
or send email to DBM\-Deep@googlegroups.com <mailto:DBM-Deep@googlegroups.com>.
You can also visit #dbm\-deep on irc.perl.org
.PP
The source code repository is at http://github.com/robkinyon/dbm\-deep <http://github.com/robkinyon/dbm-deep>
.SH "MAINTAINERS"
.IX Header "MAINTAINERS"
Rob Kinyon, rkinyon@cpan.org <mailto:rkinyon@cpan.org>
.PP
Originally written by Joseph Huckaby, jhuckaby@cpan.org <mailto:jhuckaby@cpan.org>
.SH "SPONSORS"
.IX Header "SPONSORS"
Stonehenge Consulting (<http://www.stonehenge.com/>) sponsored the
development of transactions and freespace management, leading to the 1.0000
release. A great debt of gratitude goes out to them for their continuing
leadership in and support of the Perl community.
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
The following have contributed greatly to make DBM::Deep what it is today:
.IP "\(bu" 4
Adam Sah and Rich Gaushell for innumerable contributions early on.
.IP "\(bu" 4
Dan Golden and others at \s-1YAPC::NA\s0 2006 for helping me design through transactions.
.IP "\(bu" 4
James Stanley for bug fix
.IP "\(bu" 4
David Steinbrunner for fixing typos and adding repository cpan metadata
.IP "\(bu" 4
H. Merijn Brandt for fixing the \s-1POD\s0 escapes.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIDBM::Deep::Cookbook\fR\|(3)
.PP
\&\fIperltie\fR\|(1), \fITie::Hash\fR\|(3), \fIFcntl\fR\|(3), \fIflock\fR\|(2), \fIlockf\fR\|(3),
\&\fInfs\fR\|(5)
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 2007\-14 Rob Kinyon. All Rights Reserved.
This is free software, you may use it and distribute it under the same terms
as Perl itself.
